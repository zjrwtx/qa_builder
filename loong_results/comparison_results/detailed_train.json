[
  {
    "id": 0,
    "question": "Given: A DNA string s\n of length at most 1000 nt.\n\nReturn: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s\n.\n\nSample Dataset\nAGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC",
    "execution_successful": true,
    "execution_value": "20 12 17 21",
    "expected_answer": "20 12 17 21",
    "is_match": true,
    "match_type": "exact"
  },
  {
    "id": 1,
    "question": "Given: A DNA string t\n having length at most 1000 nt.\n\nReturn: The transcribed RNA string of t\n.\n\nSample Dataset\nGATGGAACTTGACTACGTAAATT",
    "execution_successful": true,
    "execution_value": "GAUGGAACUUGACUACGUAAAUU",
    "expected_answer": "GAUGGAACUUGACUACGUAAAUU",
    "is_match": true,
    "match_type": "exact"
  },
  {
    "id": 2,
    "question": "Given: A DNA string s\n of length at most 1000 bp.\n\nReturn: The reverse complement sc\n of s\n.\n\nSample Dataset\nAAAACCCGGT",
    "execution_successful": true,
    "execution_value": "ACCGGGTTTT",
    "expected_answer": "Sample Output \nACCGGGTTTT",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 3,
    "question": "A sequence is an ordered collection of objects (usually numbers), which are allowed to repeat. Sequences can be finite or infinite. Two examples are the finite sequence (π,−2–√,0,π)\n and the infinite sequence of odd numbers (1,3,5,7,9,…)\n. We use the notation an\n to represent the n\n-th term of a sequence.\n\nA recurrence relation is a way of defining the terms of a sequence with respect to the values of previous terms. In the case of Fibonacci's rabbits from the introduction, any given month will contain the rabbits that were alive the previous month, plus any new offspring. A key observation is that the number of offspring in any month is equal to the number of rabbits that were alive two months prior. As a result, if Fn\n represents the number of rabbit pairs alive after the n\n-th month, then we obtain the Fibonacci sequence having terms Fn\n that are defined by the recurrence relation Fn=Fn−1+Fn−2\n (with F1=F2=1\n to initiate the sequence). Although the sequence bears Fibonacci's name, it was known to Indian mathematicians over two millennia ago.\n\nWhen finding the n\n-th term of a sequence defined by a recurrence relation, we can simply use the recurrence relation to generate terms for progressively larger values of n\n. This problem introduces us to the computational technique of dynamic programming, which successively builds up solutions by using the answers to smaller cases.\n\nGiven: Positive integers n≤40\n and k≤5\n.\n\nReturn: The total number of rabbit pairs that will be present after n\n months, if we begin with 1 pair and in each generation, every pair of reproduction-age rabbits produces a litter of k\n rabbit pairs (instead of only 1 pair).\n\nSample Dataset\n5 3",
    "execution_successful": true,
    "execution_value": "19",
    "expected_answer": "19",
    "is_match": true,
    "match_type": "exact"
  },
  {
    "id": 4,
    "question": "Given: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).\n\nReturn: The ID of the string having the highest GC-content, followed by the GC-content of that string. Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated; please see the note on absolute error below.\n\nSample Dataset\n>Rosalind_0808\nCCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC\nTGGGAACCTGCGGGCAGTAGGTGGAAT",
    "execution_successful": true,
    "execution_value": "('Rosalind_95', 60.0)",
    "expected_answer": "Rosalind_0808\n60.919540",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 5,
    "question": "Given two strings s\n and t\n of equal length, the Hamming distance between s\n and t\n, denoted dH(s,t)\n, is the number of corresponding symbols that differ in s\n and t\n\nGiven: Two DNA strings s\n and t\n of equal length (not exceeding 1 kbp).\n\nReturn: The Hamming distance dH(s,t)\n.\n\nSample Dataset\nGAGCCTACTAACGGGAT\nCATCGTAATGACGGCCT",
    "execution_successful": true,
    "execution_value": "7",
    "expected_answer": "7",
    "is_match": true,
    "match_type": "exact"
  },
  {
    "id": 6,
    "question": "Given: Three positive integers k\n, m\n, and n\n, representing a population containing k+m+n\n organisms: k\n individuals are homozygous dominant for a factor, m\n are heterozygous, and n\n are homozygous recessive.\n\nReturn: The probability that two randomly selected mating organisms will produce an individual possessing a dominant allele (and thus displaying the dominant phenotype). Assume that any two organisms can mate.\n\nSample Dataset\n2 2 2",
    "execution_successful": true,
    "execution_value": "0.7833333333333333",
    "expected_answer": "0.78333",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 7,
    "question": "Problem\nThe 20 commonly occurring amino acids are abbreviated by using 20 letters from the English alphabet (all letters except for B, J, O, U, X, and Z). Protein strings are constructed from these 20 symbols. Henceforth, the term genetic string will incorporate protein strings along with DNA strings and RNA strings.\n\nThe RNA codon table dictates the details regarding the encoding of specific codons into the amino acid alphabet.\n\nGiven: An RNA string s\n corresponding to a strand of mRNA (of length at most 10 kbp).\n\nReturn: The protein string encoded by s\n.\n\nSample Dataset\nAUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA",
    "execution_successful": true,
    "execution_value": "MAMAPRTEINSTRING",
    "expected_answer": "MAMAPRTEINSTRING",
    "is_match": true,
    "match_type": "exact"
  },
  {
    "id": 8,
    "question": "For DNA strings of a given length, their transition/transversion ratio $R(s_1, s_2)$ is the ratio of the total number of transitions to the total number of transversions, where symbol substitutions are inferred from mismatches of corresponding symbols as when calculating Hamming distance (see \"Counting Point Mutations\").\n\n**Given**: Two DNA strings $s_1$ and $s_2$ of equal length (at most 1 kbp).\n\n**Return**: The transition/transversion ratio $R(s_1, s_2)$.\n\n>Rosalind_0209\nGCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGA\nAGTACGGGCATCAACCCAGTT\n>Rosalind_2200\nTTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGC\nGGTACGAGTGTTCCTTTGGGT",
    "execution_successful": true,
    "execution_value": "1.2142857142857142",
    "expected_answer": "1.21428571429",
    "is_match": true,
    "match_type": "exact"
  },
  {
    "id": 9,
    "question": "As is the case with point mutations, the most common type of sequencing error occurs when a single nucleotide from a read is interpreted incorrectly.\n\nGiven: A collection of up to 1000 reads of equal length (at most 50 bp) in FASTA format. Some of these reads were generated with a single-nucleotide error. For each read s\n in the dataset, one of the following applies:\n\ns\n was correctly sequenced and appears in the dataset at least twice (possibly as a reverse complement);\ns\n is incorrect, it appears in the dataset exactly once, and its Hamming distance is 1 with respect to exactly one correct read in the dataset (or its reverse complement).\nReturn: A list of all corrections in the form \"[old read]->[new read]\". (Each correction must be a single symbol substitution, and you may return the corrections in any order.)\nSample Dataset\n>Rosalind_52\nTCATC\n>Rosalind_44\nTTCAT\n>Rosalind_68\nTCATC\n>Rosalind_28\nTGAAA\n>Rosalind_95\nGAGGA\n>Rosalind_66\nTTTCA\n>Rosalind_33\nATCAA\n>Rosalind_21\nTTGAT\n>Rosalind_18\nTTTCC",
    "execution_successful": false,
    "execution_value": "",
    "expected_answer": "TTCAT->TTGAT\nGAGGA->GATGA\nTTTCC->TTTCA",
    "is_match": false,
    "match_type": "none",
    "error_message": "Solution code error:\nTraceback (most recent call last):\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpgzdu2tpg.py\", line 54, in <module>\n    result = corrected_reads(\"input.fasta\")\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpgzdu2tpg.py\", line 15, in corrected_reads\n    rev_seq = reverse_complement(seq)\n              ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpgzdu2tpg.py\", line 5, in reverse_complement\n    return str(Seq(seq).reverse_complement())\n               ^^^\nNameError: name 'Seq' is not defined. Did you mean: 'seq'?"
  },
  {
    "id": 10,
    "question": "A binary tree is a tree in which each node has degree equal to at most 3. The binary tree will be our main tool in the construction of phylogenies.\n\nA rooted tree is a tree in which one node (the root) is set aside to serve as the pinnacle of the tree. A standard graph theory exercise is to verify that for any two nodes of a tree, exactly one path connects the nodes. In a rooted tree, every node v\n will therefore have a single parent, or the unique node w\n such that the path from v\n to the root contains {v,w}\n. Any other node x\n adjacent to v\n is called a child of v\n because v\n must be the parent of x\n; note that a node may have multiple children. In other words, a rooted tree possesses an ordered hierarchy from the root down to its leaves, and as a result, we may often view a rooted tree with undirected edges as a directed graph in which each edge is oriented from parent to child. We should already be familiar with this idea; it's how the Rosalind problem tree works!\n\nEven though a binary tree can include nodes having degree 2, an unrooted binary tree is defined more specifically: all internal nodes have degree 3. In turn, a rooted binary tree is such that only the root has degree 2 (all other internal nodes have degree 3).\n\nGiven: A positive integer n\n (3≤n≤10000\n).\n\nReturn: The number of internal nodes of any unrooted binary tree having n\n leaves.\n\nSample Dataset\n4\n",
    "execution_successful": true,
    "execution_value": "2",
    "expected_answer": "2",
    "is_match": true,
    "match_type": "exact"
  },
  {
    "id": 11,
    "question": "For a fixed positive integer k\n, order all possible k-mers taken from an underlying alphabet lexicographically.\n\nThen the k-mer composition of a string s\n can be represented by an array A\n for which A[m]\n denotes the number of times that the m\nth k-mer (with respect to the lexicographic order) appears in s\n.\n\nGiven: A DNA string s\n in FASTA format (having length at most 100 kbp).\n\nReturn: The 4-mer composition of s\n.\n\nSample Dataset\n>Rosalind_6431\nCTTCGAAAGTTTGGGCCGAGTCTTACAGTCGGTCTTGAAGCAAAGTAACGAACTCCACGG\nCCCTGACTACCGAACCAGTTGTGAGTACTCAACTGGGTGAGAGTGCAGTCCCTATTGAGT\nTTCCGAGACTCACCGGGATTTTCGATCCAGCCTCAGTCCAGTCTTGTGGCCAACTCACCA\nAATGACGTTGGAATATCCCTGTCTAGCTCACGCAGTACTTAGTAAGAGGTCGCTGCAGCG\nGGGCAAGGAGATCGGAAAATGTGCTCTATATGCGACTAAAGCTCCTAACTTACACGTAGA\nCTTGCCCGTGTTAAAAACTCGGCTCACATGCTGTCTGCGGCTGGCTGTATACAGTATCTA\nCCTAATACCCTTCAGTTCGCCGCACAAAAGCTGGGAGTTACCGCGGAAATCACAG",
    "execution_successful": false,
    "execution_value": "",
    "expected_answer": "4 1 4 3 0 1 1 5 1 3 1 2 2 1 2 0 1 1 3 1 2 1 3 1 1 1 1 2 2 5 1 3 0 2 2 1 1 1 1 3 1 0 0 1 5 5 1 5 0 2 0 2 1 2 1 1 1 2 0 1 0 0 1 1 3 2 1 0 3 2 3 0 0 2 0 8 0 0 1 0 2 1 3 0 0 0 1 4 3 2 1 1 3 1 2 1 3 1 2 1 2 1 1 1 2 3 2 1 1 0 1 1 3 2 1 2 6 2 1 1 1 2 3 3 3 2 3 0 3 2 1 1 0 0 1 4 3 0 1 5 0 2 0 1 2 1 3 0 1 2 2 1 1 0 3 0 0 4 5 0 3 0 2 1 1 3 0 3 2 2 1 1 0 2 1 0 2 2 1 2 0 2 2 5 2 2 1 1 2 1 2 2 2 2 1 1 3 4 0 2 1 1 0 1 2 2 1 1 1 5 2 0 3 2 1 1 2 2 3 0 3 0 1 3 1 2 3 0 2 1 2 2 1 2 3 0 1 2 3 1 1 3 1 0 1 1 3 0 2 1 2 2 0 2 1 1",
    "is_match": false,
    "match_type": "none",
    "error_message": "Solution code error:\nTraceback (most recent call last):\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp5lzyfvb_.py\", line 22, in <module>\n    record = next(SeqIO.parse(StringIO(fasta_str), \"fasta\"))\n                              ^^^^^^^^\nNameError: name 'StringIO' is not defined"
  },
  {
    "id": 12,
    "question": "A **prefix** of a length \\( n \\) string \\( S \\) is a substring \\( s[1 : j] \\); a **suffix** of \\( S \\) is a substring \\( s[k : n] \\).\n\nThe **failure array** of \\( S \\) is an **array** \\( P \\) of length \\( n \\) for which \\( P[k] \\) is the length of the longest substring \\( s[j : k] \\) that is equal to some prefix \\( s[1 : k - j + 1] \\), where \\( j \\) cannot equal 1 (otherwise, \\( P[k] \\) would always equal \\( k \\)). By convention, \\( P[1] = 0 \\).\n\n**Given**: A **DNA string** \\( S \\) (of length at most 100 kbp) in **FASTA format**.\n\n**Return**: The failure array of \\( S \\).\nSample Dataset\n>Rosalind_87\nCAGCATGGTATCACAGCAGAG",
    "execution_successful": false,
    "execution_value": "",
    "expected_answer": "0 0 0 1 2 0 0 0 0 0 0 1 2 1 2 3 4 5 3 0 0",
    "is_match": false,
    "match_type": "none",
    "error_message": "Solution code error:\nTraceback (most recent call last):\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpfjr09iqr.py\", line 20, in <module>\n    fasta_sequences = SeqIO.parse(fasta_str.splitlines(), \"fasta\")\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/__init__.py\", line 626, in parse\n    return iterator_generator(handle)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/FastaIO.py\", line 196, in __init__\n    super().__init__(source, fmt=\"Fasta\")\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/Interfaces.py\", line 83, in __init__\n    value = source.read(0)\n            ^^^^^^^^^^^\nAttributeError: 'list' object has no attribute 'read'"
  },
  {
    "id": 13,
    "question": "A string u\n is a common subsequence of strings s\n and t\n if the symbols of u\n appear in order as a subsequence of both s\n and t\n. For example, \"ACTG\" is a common subsequence of \"AACCTTGG\" and \"ACACTGTGA\".\n\nAnalogously to the definition of longest common substring, u\n is a longest common subsequence of s\n and t\n if there does not exist a longer common subsequence of the two strings. Continuing our above example, \"ACCTTG\" is a longest common subsequence of \"AACCTTGG\" and \"ACACTGTGA\", as is \"AACTGG\".\n\nGiven: Two DNA strings s\n and t\n (each having length at most 1 kbp) in FASTA format.\n\nReturn: A longest common subsequence of s\n and t\n. (If more than one solution exists, you may return any one.)\n\nSample Dataset\n>Rosalind_23\nAACCTTGG\n>Rosalind_64\nACACTGTGA",
    "execution_successful": false,
    "execution_value": "",
    "expected_answer": "AACTGG",
    "is_match": false,
    "match_type": "none",
    "error_message": "Solution code error:\nTraceback (most recent call last):\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp3_0vasr6.py\", line 20, in <module>\n    records = list(SeqIO.parse(fasta_data.splitlines(), \"fasta\"))\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/__init__.py\", line 626, in parse\n    return iterator_generator(handle)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/FastaIO.py\", line 196, in __init__\n    super().__init__(source, fmt=\"Fasta\")\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/Interfaces.py\", line 83, in __init__\n    value = source.read(0)\n            ^^^^^^^^^^^\nAttributeError: 'list' object has no attribute 'read'"
  },
  {
    "id": 14,
    "question": "### Problem\n\nSay that we have strings \\( S = S_1 S_2 \\cdots S_m \\) and \\( t = t_1 t_2 \\cdots t_n \\) with \\( m < n \\). Consider the substring \\( t' = t[1 : m] \\). We have two cases:\n\n1. If \\( S = t' \\), then we set \\( S <_{\\text{Lex}} t \\) because \\( S \\) is shorter than \\( t \\) (e.g., APPLE < APPLET).\n2. Otherwise, \\( S \\neq t' \\). We define \\( S <_{\\text{Lex}} t \\) if \\( S <_{\\text{Lex}} t' \\) and define \\( S >_{\\text{Lex}} t \\) if \\( S >_{\\text{Lex}} t' \\) (e.g., APPLET <_{\\text{Lex}} ARTS because APPL <_{\\text{Lex}} ARTS).\n\n**Given**: A permutation of at most 12 symbols defining an **ordered alphabet** \\( \\mathcal{A} \\) and a positive integer \\( n \\) (\\( n \\leq 4 \\)).\n\n**Return**: All strings of length at most \\( n \\) formed from \\( \\mathcal{A} \\), ordered lexicographically. (Note: As in “Enumerating k-mers Lexicographically”, alphabet order is based on the order in which the symbols are given.)\n\n---\n\n### Sample Dataset\n\n```\nD N A\n3\n```",
    "execution_successful": true,
    "execution_value": "MAMAPRTEINSTRING",
    "expected_answer": "D\nDD\nDDD\nDDN\nDDA\nDN\nDND\nDNN\nDNA\nDA\nDAD\nDAN\nDAA\nN\nND\nNDD\nNDN\nNDA\nNN\nNND\nNNN\nNNA\nNA\nNAD\nNAN\nNAA\nA\nAD\nADD\nADN\nADA\nAN\nAND\nANN\nANA\nAA\nAAD\nAAN\nAAA",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 15,
    "question": "The **graph theoretical** analogue of the quandary stated in the introduction above is that if we have an **RNA string** \\( S \\) that does not have the same number of occurrences of 'C' as 'G' and the same number of occurrences of 'A' as 'U', then the **bonding graph** of \\( S \\) cannot possibly possess a **perfect matching** among its **basepair edges**. For example, see **Figure 1**; in fact, most bonding graphs will not contain a perfect matching.\n\nIn light of this fact, we define a **maximum matching** in a graph as a **matching** containing as many **edges** as possible. See **Figure 2** for three maximum matchings in graphs.\n\nA maximum matching of basepair edges will correspond to a way of forming as many base pairs as possible in an RNA string, as shown in **Figure 3**.\n\n**Given**: An RNA string \\( S \\) of length at most 100.\n\n**Return**: The total possible number of maximum matchings of basepair edges in the bonding graph of \\( S \\).\n\n---\n\n### Sample Dataset\n\n```\n>Rosalind_92\nAUGCUUC\n```",
    "execution_successful": true,
    "execution_value": "['D', 'N', 'A', 'DD', 'DN', 'DA', 'ND', 'NN', 'NA', 'AD', 'AN', 'AA', 'DDD', 'DDN', 'DDA', 'DND', 'DNN', 'DNA', 'DAD', 'DAN', 'DAA', 'NDD', 'NDN', 'NDA', 'NND', 'NNN', 'NNA', 'NAD', 'NAN', 'NAA', 'ADD', 'ADN', 'ADA', 'AND', 'ANN', 'ANA', 'AAD', 'AAN', 'AAA']",
    "expected_answer": "6",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 16,
    "question": "0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000",
    "execution_successful": true,
    "execution_value": "[[0.0, 0.4, 0.1, 0.1], [0.4, 0.0, 0.4, 0.3], [0.1, 0.4, 0.0, 0.2], [0.1, 0.3, 0.2, 0.0]]",
    "expected_answer": "0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 17,
    "question": "For two **strings** \\( S_1 \\) and \\( S_2 \\) of equal length, the **p-distance** between them, denoted \\( d_p(S_1, S_2) \\), is the proportion of corresponding symbols that differ between \\( S_1 \\) and \\( S_2 \\).\n\nFor a general distance function \\( d \\) on \\( n \\) taxa \\( S_1, S_2, \\ldots, S_n \\) (taxa are often represented by **genetic strings**), we may encode the distances between pairs of taxa via a **distance matrix** \\( D \\) in which \\( D_{i,j} = d(S_i, S_j) \\).\n\n**Given**: A collection of \\( n \\) (\\( n \\leq 10 \\)) **DNA strings** \\( S_1, \\ldots, S_n \\) of equal length (at most 1 kbp). Strings are given in **FASTA format**.\n\n**Return**: The matrix \\( D \\) corresponding to the p-distance \\( d_p \\) on the given strings. As always, note that your answer is allowed an **absolute error** of 0.001.\n\n---\n\n### Sample Dataset\n\n```\n>Rosalind_9499\nTTTCCATTTA\n>Rosalind_0942\nGATTCA TTC\n>Rosalind_6568\nTTTCCATTTT\n>Rosalind_1833\nGTTCCATTTA\n```",
    "execution_successful": false,
    "execution_value": "",
    "expected_answer": "0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000",
    "is_match": false,
    "match_type": "none",
    "error_message": "Solution code error:\nTraceback (most recent call last):\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpj8z_7iuz.py\", line 27, in <module>\n    sequences = [str(record.seq) for record in SeqIO.parse(fasta_data.splitlines(), \"fasta\")]\n                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/__init__.py\", line 626, in parse\n    return iterator_generator(handle)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/FastaIO.py\", line 196, in __init__\n    super().__init__(source, fmt=\"Fasta\")\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp4tw0lx17/lib/python3.12/site-packages/Bio/SeqIO/Interfaces.py\", line 83, in __init__\n    value = source.read(0)\n            ^^^^^^^^^^^\nAttributeError: 'list' object has no attribute 'read'"
  },
  {
    "id": 18,
    "question": "### Problem\n\nOur aim in this problem is to determine the **probability** with which a given motif (a known promoter, say) occurs in a randomly constructed genome. Unfortunately, finding this probability is tricky; instead of forming a long genome, we will form a large collection of smaller **random strings** having the same length as the motif; these smaller strings represent the genome's **substrings**, which we can then test against our motif.\n\nGiven a **probabilistic event** \\( A \\), the **complement** of \\( A \\) is the collection \\( A^c \\) of outcomes not belonging to \\( A \\). Because \\( A^c \\) takes place precisely when \\( A \\) does not, we may also call \\( A^c \\) \"not \\( A \\).\" For a simple example, if \\( A \\) is the event that a rolled die is 2 or 4, then \\( \\text{Pr}(A) = \\frac{1}{3} \\). \\( A^c \\) is the event that the die is 1, 3, 5, or 6, and \\( \\text{Pr}(A^c) = \\frac{2}{3} \\). In general, for any event we will have the identity that \\( \\text{Pr}(A) + \\text{Pr}(A^c) = 1 \\).\n\n**Given**: A positive integer \\( N \\leq 100000 \\), a number \\( X \\) between 0 and 1, and a DNA string \\( S \\) of length at most 10 bp.\n\n**Return**: The probability that if \\( N \\) random DNA strings having the same length as \\( S \\) are constructed with **GC-content** \\( X \\) (see \"Introduction to Random Strings\"), then at least one of the strings equals \\( S \\). We allow for the same random string to be created more than once.\n\n---\n\n### Sample Dataset\n\n```\n90000 0.6\nATAGCCGA\n```",
    "execution_successful": true,
    "execution_value": "[75.0, 136.0]",
    "expected_answer": "0.689",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 19,
    "question": "A **set** is the mathematical term for a loose collection of objects, called **elements**. Examples of sets include \\(\\{\\text{the moon, the sun, Wilford Brimley}\\}\\) and \\(\\mathbb{R}\\), the set containing all real numbers. We even have the **empty set**, represented by \\(\\emptyset\\) or \\(\\{\\}\\), which contains no elements at all. Two sets are equal when they contain the same elements. In other words, in contrast to **permutations**, the ordering of the elements of a set is unimportant (e.g., \\(\\{\\text{the moon, the sun, Wilford Brimley}\\}\\) is equivalent to \\(\\{\\text{Wilford Brimley, the moon, the sun}\\}\\)). Sets are not allowed to contain duplicate elements, so that \\(\\{\\text{Wilford Brimley, the sun, the sun}\\}\\) is not a set. We have already used sets of 2 elements to represent **edges** from a **graph**.\n\nA set \\( A \\) is a **subset** of \\( B \\) if every element of \\( A \\) is also an element of \\( B \\), and we write \\( A \\subseteq B \\). For example, \\(\\{\\text{the sun, the moon}\\} \\subseteq \\{\\text{the sun, the moon, Wilford Brimley}\\}\\), and \\(\\emptyset\\) is a subset of every set (including itself).\n\nAs illustrated in the biological introduction, we can use subsets to represent the collection of taxa possessing a character. However, the number of applications is endless; for example, an **event** in **probability** can now be defined as a subset of the set containing all possible **outcomes**.\n\nOur first question is to count the total number of possible subsets of a given set.\n\n**Given**: A positive integer \\( n \\) (\\( n \\leq 1000 \\)).\n\n**Return**: The total number of subsets of \\(\\{1, 2, \\ldots, n\\}\\) modulo \\( 1,000,000 \\).\n\n---\n\n### Sample Dataset\n\n```\n3\n```",
    "execution_successful": true,
    "execution_value": "8",
    "expected_answer": "8",
    "is_match": true,
    "match_type": "exact"
  },
  {
    "id": 20,
    "question": "### Problem\n\nGiven two **strings** \\( S \\) and \\( t \\) (of possibly different lengths), the **edit distance** \\( d_E(S, t) \\) is the minimum number of **edit operations** needed to transform \\( S \\) into \\( t \\), where an edit operation is defined as the substitution, insertion, or deletion of a single symbol.\n\nThe latter two operations **incorporate** the case in which a contiguous interval is inserted into or deleted from a string; such an interval is called a **gap**. For the purposes of this problem, the insertion or deletion of a gap of length \\( k \\) still counts as \\( k \\) distinct edit operations.\n\n**Given**: Two **protein strings** \\( S \\) and \\( t \\) in **FASTA format** (each of length at most 1000 aa).\n\n**Return**: The edit distance \\( d_E(S, t) \\).\n\n---\n\n### Sample Dataset\n\n```\n>Rosalind_39\nPLEASANTLY\n>Rosalind_11\nMEANLY\n```",
    "execution_successful": true,
    "execution_value": "2",
    "expected_answer": "5",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 21,
    "question": "Say that you place a number of bets on your favorite sports teams. If their chances of winning are 0.3, 0.8, and 0.6, then you should expect on average to win 0.3 + 0.8 + 0.6 = 1.7 of your bets (of course, you can never win exactly 1.7!)\n\nMore generally, if we have a collection of events \\( A_1, A_2, \\ldots, A_n \\), then the expected number of events occurring is \\( \\Pr(A_1) + \\Pr(A_2) + \\cdots + \\Pr(A_n) \\) (consult the note following the problem for a precise explanation of this fact). In this problem, we extend the idea of finding an expected number of events to finding the expected number of times that a given string occurs as a substring of a random string.\n\nGiven: A positive integer \\( n \\) (\\( n \\leq 1,000,000 \\)), a DNA string \\( S \\) of even length at most 10, and an array \\( A \\) of length at most 20, containing numbers between 0 and 1.\n\nReturn: An array \\( B \\) having the same length as \\( A \\) in which \\( B[i] \\) represents the expected number of times that \\( S \\) will appear as a substring of a random DNA string \\( t \\) of length \\( n \\), where \\( t \\) is formed with GC-content \\( A[i] \\) (see “Introduction to Random Strings”).\n\nSample Dataset\n\n```\n10\nAG\n0.25 0.5 0.75\n```",
    "execution_successful": true,
    "execution_value": "ACCGGGTTTT",
    "expected_answer": "0.422 0.563 0.422",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 22,
    "question": "Similarly to our definition of the Catalan numbers, the \\( n \\)-th Motzkin number \\( m_n \\) counts the number of ways to form a (not necessarily perfect) noncrossing matching in the complete graph \\( K_n \\) containing \\( n \\) nodes. For example, Figure 1 demonstrates that \\( m_6 = 21 \\). Note in this figure that technically, the \"trivial\" matching that contains no edges at all is considered to be a matching, because it satisfies the defining condition that no two edges are incident to the same node.\n\nHow should we compute the Motzkin numbers? As with Catalan numbers, we will take \\( m_0 = m_1 = 1 \\). To calculate \\( m_n \\) in general, assume that the nodes of \\( K_n \\) are labeled around the outside of a circle with the integers between 1 and \\( n \\), and consider node 1, which may or may not be involved in a matching. If node 1 is not involved in a matching, then there are \\( m_{n-1} \\) ways of matching the remaining \\( n-1 \\) nodes. If node 1 is involved in a matching, then say it is matched to node \\( k \\): this leaves \\( k-2 \\) nodes on one side of edge \\( \\{1, k\\} \\) and \\( n-k \\) nodes on the other side; as with the Catalan numbers, no edge can connect the two sides, which gives us \\( m_{k-2} \\cdot m_{n-k} \\) ways of matching the remaining edges. Allowing \\( k \\) to vary between 2 and \\( n \\) yields the following recurrence relation for the Motzkin numbers: \\( m_n = m_{n-1} + \\sum_{k=2}^n m_{k-2} \\cdot m_{n-k} \\).\n\nTo count all possible secondary structures of a given RNA string that do not contain pseudoknots, we need to modify the Motzkin recurrence so that it counts only matchings of basepair edges in the bonding graph corresponding to the RNA string; see Figure 2.\n\nGiven: An RNA string \\( S \\) of length at most 300 bp.\n\nReturn: The total number of noncrossing matchings of basepair edges in the bonding graph of \\( S \\), modulo 1,000,000.\n\nSample Dataset\n\n```\n>Rosalind_57\nAUAU\n```",
    "execution_successful": true,
    "execution_value": "19",
    "expected_answer": "7",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 23,
    "question": "Newick format is a way of representing trees even more concisely than using an adjacency list, especially when dealing with trees whose internal nodes have not been labeled.\n\nFirst, consider the case of a rooted tree \\( T \\). A collection of leaves \\( V_1, V_2, \\ldots, V_n \\) of \\( T \\) are neighbors if they are all adjacent to some internal node \\( U \\). Newick format for \\( T \\) is obtained by iterating the following key step: delete all the edges \\( \\{V_i, U\\} \\) from \\( T \\) and label \\( U \\) with \\( (V_1, V_2, \\ldots, V_n)U \\). This process is repeated all the way to the root, at which point a semicolon signals the end of the tree.\n\nA number of variations of Newick format exist. First, if a node is not labeled in \\( T \\), then we simply leave blank the space occupied by the node. In the key step, we can write \\( (V_1, V_2, \\ldots, V_n) \\) in place of \\( (V_1, V_2, \\ldots, V_n)U \\) if the \\( V_i \\) are labeled; if none of the nodes are labeled, we can write \\( (, , \\ldots, ) \\).\n\nA second variation of Newick format occurs when \\( T \\) is unrooted, in which case we simply select any internal node to serve as the root of \\( T \\). A particularly peculiar case of Newick format arises when we choose a leaf to serve as the root.\n\nNote that there will be a large number of different ways to represent \\( T \\) in Newick format; see Figure 1.\n\nGiven: A collection of \\( n \\) trees (\\( n \\leq 40 \\)) in Newick format, with each tree containing at most 200 nodes; each tree \\( T_k \\) is followed by a pair of nodes \\( x_k \\) and \\( y_k \\) in \\( T_k \\).\n\nReturn: A collection of \\( n \\) positive integers, for which the \\( k \\)-th integer represents the distance between \\( x_k \\) and \\( y_k \\) in \\( T_k \\).\n\nSample Dataset\n\n```\n(cat)dog;\ndog cat\n\n(dog,cat);\ndog cat\n```",
    "execution_successful": true,
    "execution_value": "[0, 0]",
    "expected_answer": "1 2",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 24,
    "question": "A string s\n is a supersequence of another string t\n if s\n contains t\n as a subsequence.\n\nA common supersequence of strings s\n and t\n is a string that serves as a supersequence of both s\n and t\n. For example, \"GACCTAGGAACTC\" serves as a common supersequence of \"ACGTC\" and \"ATAT\". A shortest common supersequence of s\n and t\n is a supersequence for which there does not exist a shorter common supersequence. Continuing our example, \"ACGTACT\" is a shortest common supersequence of \"ACGTC\" and \"ATAT\".\n\nGiven: Two DNA strings s\n and t\n.\n\nReturn: A shortest common supersequence of s\n and t\n. If multiple solutions exist, you may output any one.\n\nSample Dataset\nATCTGAT\nTGCATA",
    "execution_successful": false,
    "execution_value": "",
    "expected_answer": "ATGCATGAT",
    "is_match": false,
    "match_type": "none",
    "error_message": "Solution code error:\nTraceback (most recent call last):\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmp9_0rfei6.py\", line 21, in <module>\n    records = SeqIO.parse(fasta_data.splitlines(), \"fasta\")\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpvsng6xko/lib/python3.12/site-packages/Bio/SeqIO/__init__.py\", line 626, in parse\n    return iterator_generator(handle)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpvsng6xko/lib/python3.12/site-packages/Bio/SeqIO/FastaIO.py\", line 196, in __init__\n    super().__init__(source, fmt=\"Fasta\")\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpvsng6xko/lib/python3.12/site-packages/Bio/SeqIO/Interfaces.py\", line 83, in __init__\n    value = source.read(0)\n            ^^^^^^^^^^^\nAttributeError: 'list' object has no attribute 'read'"
  },
  {
    "id": 25,
    "question": "A reversal of a permutation can be encoded by the two indices at the endpoints of the interval that it inverts; for example, the reversal that transforms \\( (4, 1, 2, 6, 3, 5) \\) into \\( (4, 1, 3, 6, 2, 5) \\) is encoded by \\( [3, 5] \\).\n\nA collection of reversals sorts \\( \\Pi \\) into \\( \\gamma \\) if the collection contains \\( d_{\\text{rev}}(\\Pi, \\gamma) \\) reversals, which when successively applied to \\( \\Pi \\) yield \\( \\gamma \\).\n\nGiven: Two permutations \\( \\Pi \\) and \\( \\gamma \\), each of length 10.\n\nReturn: The reversal distance \\( d_{\\text{rev}}(\\Pi, \\gamma) \\), followed by a collection of reversals sorting \\( \\Pi \\) into \\( \\gamma \\). If multiple collections of such reversals exist, you may return any one.\n\nSample Dataset\n\n```\n1 2 3 4 5 6 7 8 9 10\n1 8 9 3 2 7 6 5 4 10\n```",
    "execution_successful": true,
    "execution_value": "MAMAPRTEINSTRING",
    "expected_answer": "2\n4 9\n2 5",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 26,
    "question": "The prefix spectrum of a weighted string is the collection of all its prefix weights.\n\nGiven: A list L\n of n\n (n≤100\n) positive real numbers.\n\nReturn: A protein string of length n−1\n whose prefix spectrum is equal to L\n (if multiple solutions exist, you may output any one of them). Consult the monoisotopic mass table.\n\nSample Dataset\n3524.8542\n3710.9335\n3841.974\n3970.0326\n4057.0646",
    "execution_successful": true,
    "execution_value": "1.2142857142857142",
    "expected_answer": "WMQS",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 27,
    "question": "Given a collection of strings, their trie (often pronounced \"try\" to avoid ambiguity with the general term tree) is a rooted tree formed as follows. For every unique first symbol in the strings, an edge is formed connecting the root to a new vertex. This symbol is then used to label the edge.\n\nWe may then iterate the process by moving down one level as follows. Say that an edge connecting the root to a node \\( V \\) is labeled with 'A'; then we delete the first symbol from every string in the collection beginning with 'A' and then treat \\( V \\) as our root. We apply this process to all nodes that are adjacent to the root, and then we move down another level and continue. See Figure 1 for an example of a trie.\n\nAs a result of this method of construction, the symbols along the edges of any path in the trie from the root to a leaf will spell out a unique string from the collection, as long as no string is a prefix of another in the collection (this would cause the first string to be encoded as a path terminating at an internal node).\n\nGiven: A list of at most 100 DNA strings of length at most 100 bp, none of which is a prefix of another.\n\nReturn: The adjacency list corresponding to the trie \\( T \\) for these patterns, in the following format. If \\( T \\) has \\( n \\) nodes, first label the root with 1 and then label the remaining nodes with the integers 2 through \\( n \\) in any order you like. Each edge of the adjacency list of \\( T \\) will be encoded by a triple containing the integer representing the edge's parent node, followed by the integer representing the edge's child node, and finally the symbol labeling the edge.\n\nSample Dataset\n\n```\nATAGA\nATC\nGAT\n```",
    "execution_successful": false,
    "execution_value": "",
    "expected_answer": "1 2 A\n2 3 T\n3 4 A\n4 5 G\n5 6 A\n3 7 C\n1 8 G\n8 9 A\n9 10 T",
    "is_match": false,
    "match_type": "none",
    "error_message": "Solution code error:\nTraceback (most recent call last):\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpljifs58z.py\", line 24, in <module>\n    records = SeqIO.parse(fasta_data.splitlines(), \"fasta\")\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpvsng6xko/lib/python3.12/site-packages/Bio/SeqIO/__init__.py\", line 626, in parse\n    return iterator_generator(handle)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpvsng6xko/lib/python3.12/site-packages/Bio/SeqIO/FastaIO.py\", line 196, in __init__\n    super().__init__(source, fmt=\"Fasta\")\n  File \"/var/folders/2q/_bzfv_vn0lngh7kmv0q_3rm00000gn/T/tmpvsng6xko/lib/python3.12/site-packages/Bio/SeqIO/Interfaces.py\", line 83, in __init__\n    value = source.read(0)\n            ^^^^^^^^^^^\nAttributeError: 'list' object has no attribute 'read'"
  },
  {
    "id": 28,
    "question": "A **multiset** is a generalization of the notion of **set** to include a collection of objects in which each object may occur more than once (the order in which objects are given is still unimportant). For a multiset \\( S \\), the **multiplicity** of an element \\( X \\) is the number of times that \\( X \\) occurs in the set; this multiplicity is denoted \\( S(X) \\). Note that every set is included in the definition of multiset.\n\nThe **Minkowski sum** of multisets \\( S_1 \\) and \\( S_2 \\) containing real numbers is the new multiset \\( S_1 \\oplus S_2 \\) formed by taking all possible sums \\( s_1 + s_2 \\) of an element \\( s_1 \\) from \\( S_1 \\) and an element \\( s_2 \\) from \\( S_2 \\). The Minkowski sum could be defined more concisely as \\( S_1 \\oplus S_2 = \\{s_1 + s_2 : s_1 \\in S_1, s_2 \\in S_2\\} \\). The **Minkowski difference** \\( S_1 \\ominus S_2 \\) is defined analogously by taking all possible differences \\( s_1 - s_2 \\).\n\nIf \\( S_1 \\) and \\( S_2 \\) represent simplified spectra taken from two peptides, then \\( S_1 \\ominus S_2 \\) is called the **spectral convolution** of \\( S_1 \\) and \\( S_2 \\). In this notation, the shared peaks count is represented by \\( (S_2 \\ominus S_1)(0) \\), and the value of \\( x \\) for which \\( (S_2 \\ominus S_1)(x) \\) has the maximal value is the shift value maximizing the number of shared masses of \\( S_1 \\) and \\( S_2 \\).\n\nGiven: Two multisets of positive real numbers \\( S_1 \\) and \\( S_2 \\). The size of each multiset is at most 200.\n\nReturn: The largest multiplicity of \\( S_1 \\ominus S_2 \\), as well as the absolute value of the number \\( x \\) maximizing \\( (S_1 \\ominus S_2)(x) \\) (you may return any such value if multiple solutions exist).\n\nSample Dataset\n\n```\n186.07931 287.12699 548.20532 580.18077 681.22845 706.27446 782.27613 968.35544 968.35544\n101.04768 158.06914 202.09536 318.09979 419.14747 463.17369\n```",
    "execution_successful": true,
    "execution_value": "[75.0, 136.0]",
    "expected_answer": "3\n85.03163",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 29,
    "question": "Given a collection of \\( N \\) taxa, any subset \\( S \\) of these taxa can be seen as encoding a character that divides the taxa into the sets \\( S \\) and \\( S^c \\); we can represent the character by \\( S \\mid S^c \\), which is called a **split**. Alternately, the character can be represented by a **character array** \\( A \\) of length \\( N \\) for which \\( A[j] = 1 \\) if the \\( j \\)-th taxon belongs to \\( S \\) and \\( A[j] = 0 \\) if the \\( j \\)-th taxon belongs to \\( S^c \\) (recall the \"ON\"/\"OFF\" analogy from \"Counting Subsets\").\n\nAt the same time, observe that the removal of an edge from an **unrooted binary tree** produces two separate trees, each one containing a subset of the original taxa. So each edge may also be encoded by a split \\( S \\mid S^c \\).\n\nA **trivial character** isolates a single taxon into a group of its own. The corresponding split \\( S \\mid S^c \\) must be such that \\( S \\) or \\( S^c \\) contains only one element; the edge encoded by this split must be incident to a leaf of the unrooted binary tree, and the array for the character contains exactly one 0 or exactly one 1. Trivial characters are of no phylogenetic interest because they fail to provide us with information regarding the relationships of taxa to each other. All other characters are called **nontrivial characters** (and the associated splits are called **nontrivial splits**).\n\nA **character table** is a matrix \\( C \\) in which each row represents the array notation for a nontrivial character. That is, entry \\( C_{i,j} \\) denotes the \"ON\"/\"OFF\" position of the \\( i \\)-th character with respect to the \\( j \\)-th taxon.\n\nGiven: An unrooted binary tree \\( T \\) in **Newick format** for at most 200 species taxa.\n\nReturn: A character table having the same splits as the edge splits of \\( T \\). The columns of the character table should encode the taxa ordered lexicographically; the rows of the character table may be given in any order. Also, for any given character, the particular subset of taxa to which 1s are assigned is arbitrary.\n\nSample Dataset\n\n```\n(dog,((elephant,mouse),robot),cat);\n```",
    "execution_successful": true,
    "execution_value": "8",
    "expected_answer": "00110\n00111",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 30,
    "question": "Consider a set \\( S \\) of \\( (k+1) \\)-mers of some unknown DNA string. Let \\( S^{\\text{rc}} \\) denote the set containing all reverse complements of the elements of \\( S \\). (Recall from \"Counting Subsets\" that sets are not allowed to contain duplicate elements).\n\nThe **de Bruijn graph** \\( B_k \\) of order \\( k \\) corresponding to \\( S \\cup S^{\\text{rc}} \\) is a digraph defined in the following way:\n\n- Nodes of \\( B_k \\) correspond to all \\( k \\)-mers that are present as a substring of a \\( (k+1) \\)-mer from \\( S \\cup S^{\\text{rc}} \\).\n- Edges of \\( B_k \\) are encoded by the \\( (k+1) \\)-mers of \\( S \\cup S^{\\text{rc}} \\) in the following way: for each \\( (k+1) \\)-mer \\( r \\) in \\( S \\cup S^{\\text{rc}} \\), form a directed edge \\( (r[1:k], r[2:k+1]) \\).\n\nGiven: A collection of up to 1000 (possibly repeating) DNA strings of equal length (not exceeding 50 bp) corresponding to a set \\( S \\) of \\( (k+1) \\)-mers.\n\nReturn: The adjacency list corresponding to the de Bruijn graph corresponding to \\( S \\cup S^{\\text{rc}} \\).\n\nSample Dataset\n\n```\nTGAT\nCATG\nTCAT\nATGC\nCATC\nCATC\n```",
    "execution_successful": true,
    "execution_value": "[('ATC', 'TCA'), ('ATG', 'TGA'), ('ATG', 'TGC'), ('CAT', 'ATC'), ('CAT', 'ATC'), ('CAT', 'ATG'), ('CAT', 'ATG'), ('GAT', 'ATG'), ('GAT', 'ATG'), ('GCA', 'CAT'), ('TCA', 'CAT'), ('TGA', 'GAT')]",
    "expected_answer": "(ATC, TCA)\n(ATG, TGA)\n(ATG, TGC)\n(CAT, ATC)\n(CAT, ATG)\n(GAT, ATG)\n(GCA, CAT)\n(TCA, CAT)\n(TGA, GAT)",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 31,
    "question": "An **alignment** of two strings \\( S \\) and \\( t \\) is defined by two strings \\( S' \\) and \\( t' \\) satisfying the following three conditions:\n\n1. \\( S' \\) and \\( t' \\) must be formed from adding **gap symbols** \"-\" to each of \\( S \\) and \\( t \\), respectively; as a result, \\( S \\) and \\( t \\) will form subsequences of \\( S' \\) and \\( t' \\).\n2. \\( S' \\) and \\( t' \\) must have the same length.\n3. Two gap symbols may not be aligned; that is, if \\( S'[j] \\) is a gap symbol, then \\( t'[j] \\) cannot be a gap symbol, and vice-versa.\n\nWe say that \\( S' \\) and \\( t' \\) **augment** \\( S \\) and \\( t \\). Writing \\( S' \\) directly over \\( t' \\) so that symbols are **aligned** provides us with a scenario for transforming \\( S \\) into \\( t \\). Mismatched symbols from \\( S \\) and \\( t \\) correspond to symbol substitutions; a gap symbol \\( S'[j] \\) aligned with a non-gap symbol \\( t'[j] \\) implies the insertion of this symbol into \\( t \\); a gap symbol \\( t'[j] \\) aligned with a non-gap symbol \\( S'[j] \\) implies the deletion of this symbol from \\( S \\).\n\nThus, an alignment represents a transformation of \\( S \\) into \\( t \\) via edit operations. We define the corresponding **edit alignment score** of \\( S' \\) and \\( t' \\) as \\( d_H(S', t') \\) (Hamming distance is used because the gap symbol has been introduced for insertions and deletions). It follows that \\( d_E(S, t) = \\min_{S', t'} d_H(S', t') \\), where the minimum is taken over all alignments of \\( S \\) and \\( t \\). We call such a minimum score alignment an **optimal alignment** (with respect to edit distance).\n\nGiven: Two **protein strings** \\( S \\) and \\( t \\) in FASTA format (with each string having length at most 1000 aa).\n\nReturn: The edit distance \\( d_E(S, t) \\) followed by two augmented strings \\( S' \\) and \\( t' \\) representing an optimal alignment of \\( S \\) and \\( t \\).\n\nSample Dataset\n\n```\n>Rosalind_43\nPRETTY\n>Rosalind_97\nPRTTEIN\n```",
    "execution_successful": true,
    "execution_value": "(2, 'TCAT', 'TTTCAT')",
    "expected_answer": "4\nPRETTY--\nPR-TTEIN",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 32,
    "question": "Say that we have a string \\( S \\) containing \\( t \\) as an internal substring, so that there exist nonempty substrings \\( S_1 \\) and \\( S_2 \\) of \\( S \\) such that \\( S \\) can be written as \\( S_1 t S_2 \\). A **t-prefix** contains all of \\( S_1 \\) and none of \\( S_2 \\); likewise, a **t-suffix** contains all of \\( S_2 \\) and none of \\( S_1 \\).\n\nGiven: A list \\( L \\) containing \\( 2n + 3 \\) positive real numbers (\\( n \\leq 100 \\)). The first number in \\( L \\) is the parent mass of a peptide \\( P \\), and all other numbers represent the masses of some b-ions and y-ions of \\( P \\) (in no particular order). You may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.\n\nReturn: A protein string \\( t \\) of length \\( n \\) for which there exist two positive real numbers \\( W_1 \\) and \\( W_2 \\) such that for every prefix \\( p \\) and suffix \\( s \\) of \\( t \\), each of \\( w(p) + W_1 \\) and \\( w(s) + W_2 \\) is equal to an element of \\( L \\). (In other words, there exists a protein string whose t-prefix and t-suffix weights correspond to the non-parent mass values of \\( L \\).) If multiple solutions exist, you may output any one.\n\nSample Dataset\n\n```\n1988.21104821\n610.391039105\n738.485999105\n766.492149105\n863.544909105\n867.528589105\n992.587499105\n995.623549105\n1120.6824591\n1124.6661391\n1221.7188991\n1249.7250491\n1377.8200091\n```",
    "execution_successful": true,
    "execution_value": "7",
    "expected_answer": "KEKEP",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 33,
    "question": "Consider a collection of coin flips. One of the most natural questions we can ask is if we flip a coin 92 times, what is the **probability** of obtaining 51 \"heads\", vs. 27 \"heads\", vs. 92 \"heads\"?\n\nEach coin flip can be modeled by a **uniform random variable** in which each of the two outcomes (\"heads\" and \"tails\") has probability equal to \\( \\frac{1}{2} \\). We may assume that these random variables are **independent** (see \"Independent Alleles\"); in layman's terms, the outcomes of the two coin flips do not influence each other.\n\nA **binomial random variable** \\( X \\) takes a value of \\( k \\) if \\( n \\) consecutive \"coin flips\" result in \\( k \\) total \"heads\" and \\( n - k \\) total \"tails.\" We write that \\( X \\in \\text{Bin}(n, \\frac{1}{2}) \\).\n\nGiven: A positive integer \\( n \\leq 50 \\).\n\nReturn: An array \\( A \\) of length \\( 2n \\) in which \\( A[k] \\) represents the **common logarithm** of the probability that two diploid siblings share at least \\( k \\) of their \\( 2n \\) chromosomes (we do not consider recombination for now).\n\nSample Dataset\n\n```\n5\n```",
    "execution_successful": true,
    "execution_value": "[0.0, -0.00042432292765179444, -0.0046905112795315234, -0.024424599331418283, -0.08190410438309813, -0.20547927791864962, -0.423712651968057, -0.7647872888256622, -1.2621119296336116, -1.968907271481587, -3.010299956639812]",
    "expected_answer": "0.000 -0.004 -0.024 -0.082 -0.206 -0.424 -0.765 -1.262 -1.969 -3.010",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 34,
    "question": "Given three strings \\( S \\), \\( t \\), and \\( u \\), we say that \\( t \\) and \\( u \\) can be **interwoven** into \\( S \\) if there is some substring of \\( S \\) made up of \\( t \\) and \\( u \\) as disjoint subsequences.\n\nFor example, the strings \"ACAG\" and \"CCG\" can be interwoven into \"GACCACGGTT\". However, they cannot be interwoven into \"GACCACAAAAGGT\" because of the appearance of the four 'A's in the middle of the subsequences. Similarly, even though both \"ACACG\" is a shortest common supersequence of ACAG and CCG, it is not possible to interweave these two strings into \"ACACG\" because the two desired subsequences must be disjoint; see \"Interleaving Two Motifs\" for details on finding a shortest common supersequence of two strings.\n\nGiven: A text DNA string \\( S \\) of length at most 10 kbp, followed by a collection of \\( n \\) (\\( n \\leq 10 \\)) DNA strings of length at most 10 bp acting as patterns.\n\nReturn: An \\( n \\times n \\) matrix \\( M \\) for which \\( M_{j,k} = 1 \\) if the \\( j \\)-th and \\( k \\)-th pattern strings can be interwoven into \\( S \\) and \\( M_{j,k} = 0 \\) otherwise.\n\nSample Dataset\n\n```\nGACCACGGTT\nACAG\nGT\nCCG\n```",
    "execution_successful": true,
    "execution_value": "[[0, 1, 0], [0, 0, 0], [0, 1, 0]]",
    "expected_answer": "0 0 1\n0 1 0\n1 0 0",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 35,
    "question": "A **repeated substring** of a string \\( S \\) of length \\( n \\) is simply a substring that appears in more than one location of \\( S \\); more specifically, a **k-fold substring** appears in at least \\( k \\) distinct locations.\n\nThe **suffix tree** of \\( S \\), denoted \\( T(S) \\), is defined as follows:\n\n- \\( T(S) \\) is a rooted tree having exactly \\( n \\) leaves.\n- Every edge of \\( T(S) \\) is labeled with a substring of \\( S^* \\), where \\( S^* \\) is the string formed by adding a placeholder symbol \\( \\$ \\) to the end of \\( S \\).\n- Every internal node of \\( T(S) \\) other than the root has at least two children; i.e., it has degree at least 3.\n- The substring labels for the edges leading from a node to its children must begin with different symbols.\n- By concatenating the substrings along edges, each path from the root to a leaf corresponds to a unique suffix of \\( S^* \\).\n\nSee Figure 1 for an example of a suffix tree.\n\nGiven: A DNA string \\( S \\) (of length at most 20 kbp) with \\( \\$ \\) appended, a positive integer \\( k \\), and a list of edges defining the suffix tree of \\( S \\). Each edge is represented by four components:\n\n1. The label of its parent node in \\( T(S) \\);\n2. The label of its child node in \\( T(S) \\);\n3. The location of the substring \\( t \\) of \\( S^* \\) assigned to the edge; and\n4. The length of \\( t \\).\n\nReturn: The longest substring of \\( S \\) that occurs at least \\( k \\) times in \\( S \\). (If multiple solutions exist, you may return any single solution.)\n\nSample Dataset\nCATACATAC$\n2\nnode1 node2 1 1\nnode1 node7 2 1\nnode1 node14 3 3\nnode1 node17 10 1\nnode2 node3 2 4\nnode2 node6 10 1\nnode3 node4 6 5\nnode3 node5 10 1\nnode7 node8 3 3\nnode7 node11 5 1\nnode8 node9 6 5\nnode8 node10 10 1\nnode11 node12 6 5\nnode11 node13 10 1\nnode14 node15 6 5\nnode14 node16 10 1",
    "execution_successful": true,
    "execution_value": "1.2142857142857142",
    "expected_answer": "CATAC",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 36,
    "question": "In a **weighted tree**, each edge is assigned a (usually positive) number, called its **weight**. The **distance** between two nodes in a weighted tree becomes the sum of the weights along the unique path connecting the nodes.\n\nTo generalize **Newick format** to the case of a weighted tree \\( T \\), during our repeated \"key step,\" if leaves \\( V_1, V_2, \\ldots, V_n \\) are **neighbors** in \\( T \\), and all these leaves are incident to \\( U \\), then we replace \\( U \\) with \\( (V_1 : d_1, V_2 : d_2, \\ldots, V_n : d_n)U \\), where \\( d_i \\) is now the weight on the edge \\( \\{V_i, U\\} \\).\n\nGiven: A collection of \\( n \\) weighted trees (\\( n \\leq 40 \\)) in Newick format, with each tree containing at most 200 nodes; each tree \\( T_k \\) is followed by a pair of nodes \\( X_k \\) and \\( Y_k \\) in \\( T_k \\).\n\nReturn: A collection of \\( n \\) numbers, for which the \\( k \\)-th number represents the distance between \\( X_k \\) and \\( Y_k \\) in \\( T_k \\).\n\nSample Dataset\n\n```\n(dog:42,cat:33);\ncat dog\n\n((dog:4,cat:3):74,robot:98,elephant:58);\ndog elephant\n```",
    "execution_successful": true,
    "execution_value": "[75.0, 136.0]",
    "expected_answer": "75 136",
    "is_match": false,
    "match_type": "none"
  },
  {
    "id": 37,
    "question": "Given an RNA string \\( S \\), we will augment the **bonding graph** of \\( S \\) by adding **basepair edges** connecting all occurrences of 'U' to all occurrences of 'G' in order to represent possible wobble base pairs.\n\nWe say that a matching in the bonding graph for \\( S \\) is **valid** if it is **noncrossing** (to prevent pseudoknots) and has the property that a basepair edge in the matching cannot connect symbols \\( S_j \\) and \\( S_k \\) unless \\( k \\geq j + 4 \\) (to prevent nearby nucleotides from base pairing).\n\nSee Figure 1 for an example of a valid matching if we allow wobble base pairs. In this problem, we will wish to count all possible valid matchings in a given bonding graph; see Figure 2 for all possible valid matchings in a small bonding graph, assuming that we allow wobble base pairing.\n\nGiven: An RNA string \\( S \\) (of length at most 200 bp).\n\nReturn: The total number of **distinct** valid matchings of basepair edges in the bonding graph of \\( S \\). Assume that wobble base pairing is allowed.\n\n\nSample Dataset\nAUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU",
    "execution_successful": true,
    "execution_value": "[75.0, 136.0]",
    "expected_answer": "284850219977421",
    "is_match": false,
    "match_type": "none"
  }
]