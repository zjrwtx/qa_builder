[
  {
    "question": "Given: A DNA string s\n of length at most 1000 nt.\n\nReturn: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s\n.\n\nSample Dataset\nAGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC",
    "final_answer": "20 12 17 21",
    "rationale": "from Bio.Seq import Seq\n\ns = \"AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC\"\nsequence = Seq(s)\n\na_count = sequence.count('A')\nc_count = sequence.count('C')\ng_count = sequence.count('G')\nt_count = sequence.count('T')\n\nresult = f\"{a_count} {c_count} {g_count} {t_count}\"\nprint(result)"
  },
  {
    "question": "Given: A DNA string t\n having length at most 1000 nt.\n\nReturn: The transcribed RNA string of t\n.\n\nSample Dataset\nGATGGAACTTGACTACGTAAATT",
    "final_answer": "GAUGGAACUUGACUACGUAAAUU",
    "rationale": "from Bio.Seq import Seq\n\nt = \"GATGGAACTTGACTACGTAAATT\"\ndna_seq = Seq(t)\n\nrna_seq = dna_seq.transcribe()\n\nresult = str(rna_seq)\nprint(result)"
  },
  {
    "question": "Given: A DNA string s\n of length at most 1000 bp.\n\nReturn: The reverse complement sc\n of s\n.\n\nSample Dataset\nAAAACCCGGT",
    "final_answer": "ACCGGGTTTT",
    "rationale": "from Bio.Seq import Seq\n\ns = \"AAAACCCGGT\"\ndna_seq = Seq(s)\n\nreverse_complement_seq = dna_seq.reverse_complement()\n\nresult = str(reverse_complement_seq)\nprint(result)"
  },
  {
    "question": "A sequence is an ordered collection of objects (usually numbers), which are allowed to repeat. Sequences can be finite or infinite. Two examples are the finite sequence (π,−2–√,0,π)\n and the infinite sequence of odd numbers (1,3,5,7,9,…)\n. We use the notation an\n to represent the n\n-th term of a sequence.\n\nA recurrence relation is a way of defining the terms of a sequence with respect to the values of previous terms. In the case of Fibonacci's rabbits from the introduction, any given month will contain the rabbits that were alive the previous month, plus any new offspring. A key observation is that the number of offspring in any month is equal to the number of rabbits that were alive two months prior. As a result, if Fn\n represents the number of rabbit pairs alive after the n\n-th month, then we obtain the Fibonacci sequence having terms Fn\n that are defined by the recurrence relation Fn=Fn−1+Fn−2\n (with F1=F2=1\n to initiate the sequence). Although the sequence bears Fibonacci's name, it was known to Indian mathematicians over two millennia ago.\n\nWhen finding the n\n-th term of a sequence defined by a recurrence relation, we can simply use the recurrence relation to generate terms for progressively larger values of n\n. This problem introduces us to the computational technique of dynamic programming, which successively builds up solutions by using the answers to smaller cases.\n\nGiven: Positive integers n≤40\n and k≤5\n.\n\nReturn: The total number of rabbit pairs that will be present after n\n months, if we begin with 1 pair and in each generation, every pair of reproduction-age rabbits produces a litter of k\n rabbit pairs (instead of only 1 pair).\n\nSample Dataset\n5 3",
    "final_answer": "19",
    "rationale": "n = 5\nk = 3\n\ndef fib_rabbit(n, k):\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return fib_rabbit(n-1, k) + k * fib_rabbit(n-2, k)\n\nresult = fib_rabbit(n, k)\nprint(result)"
  },
  {
    "question": "Given two strings s\n and t\n of equal length, the Hamming distance between s\n and t\n, denoted dH(s,t)\n, is the number of corresponding symbols that differ in s\n and t\n\nGiven: Two DNA strings s\n and t\n of equal length (not exceeding 1 kbp).\n\nReturn: The Hamming distance dH(s,t)\n.\n\nSample Dataset\nGAGCCTACTAACGGGAT\nCATCGTAATGACGGCCT",
    "final_answer": "7",
    "rationale": "s = \"GAGCCTACTAACGGGAT\"\nt = \"CATCGTAATGACGGCCT\"\n\nhamming_distance = sum(sc != tc for sc, tc in zip(s, t))\n\nresult = hamming_distance\nprint(result)"
  },
  {
    "question": "Given: Three positive integers k\n, m\n, and n\n, representing a population containing k+m+n\n organisms: k\n individuals are homozygous dominant for a factor, m\n are heterozygous, and n\n are homozygous recessive.\n\nReturn: The probability that two randomly selected mating organisms will produce an individual possessing a dominant allele (and thus displaying the dominant phenotype). Assume that any two organisms can mate.\n\nSample Dataset\n2 2 2",
    "final_answer": "0.78333",
    "rationale": "k, m, n = 2, 2, 2\n\ntotal = k + m + n\n\n# Probabilities for each pair producing a dominant phenotype\nprob_dominant = (k/total) * ((k-1)/(total-1)) + (k/total) * (m/(total-1)) + (k/total) * (n/(total-1))\nprob_dominant += (m/total) * (k/(total-1)) + (m/total) * ((m-1)/(total-1)) * 0.75 + (m/total) * (n/(total-1)) * 0.5\nprob_dominant += (n/total) * (k/(total-1)) + (n/total) * (m/(total-1)) * 0.5\n\nresult = prob_dominant\nprint(result)"
  },
  {
    "question": "Problem\nThe 20 commonly occurring amino acids are abbreviated by using 20 letters from the English alphabet (all letters except for B, J, O, U, X, and Z). Protein strings are constructed from these 20 symbols. Henceforth, the term genetic string will incorporate protein strings along with DNA strings and RNA strings.\n\nThe RNA codon table dictates the details regarding the encoding of specific codons into the amino acid alphabet.\n\nGiven: An RNA string s\n corresponding to a strand of mRNA (of length at most 10 kbp).\n\nReturn: The protein string encoded by s\n.\n\nSample Dataset\nAUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA",
    "final_answer": "MAMAPRTEINSTRING",
    "rationale": "from Bio.Seq import Seq\n\nrna_string = \"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\"\nrna_seq = Seq(rna_string)\n\nprotein_string = str(rna_seq.translate(to_stop=True))\n\nresult = protein_string\nprint(result)"
  },
  {
    "question": "A binary tree is a tree in which each node has degree equal to at most 3. The binary tree will be our main tool in the construction of phylogenies.\n\nA rooted tree is a tree in which one node (the root) is set aside to serve as the pinnacle of the tree. A standard graph theory exercise is to verify that for any two nodes of a tree, exactly one path connects the nodes. In a rooted tree, every node v\n will therefore have a single parent, or the unique node w\n such that the path from v\n to the root contains {v,w}\n. Any other node x\n adjacent to v\n is called a child of v\n because v\n must be the parent of x\n; note that a node may have multiple children. In other words, a rooted tree possesses an ordered hierarchy from the root down to its leaves, and as a result, we may often view a rooted tree with undirected edges as a directed graph in which each edge is oriented from parent to child. We should already be familiar with this idea; it's how the Rosalind problem tree works!\n\nEven though a binary tree can include nodes having degree 2, an unrooted binary tree is defined more specifically: all internal nodes have degree 3. In turn, a rooted binary tree is such that only the root has degree 2 (all other internal nodes have degree 3).\n\nGiven: A positive integer n\n (3≤n≤10000\n).\n\nReturn: The number of internal nodes of any unrooted binary tree having n\n leaves.\n\nSample Dataset\n4\n",
    "final_answer": "2",
    "rationale": "from math import ceil\nn = 4\ninternal_nodes = n - 2\nresult = internal_nodes\nprint(result)"
  },
  {
    "question": "### Problem\n\nSay that we have strings \\( S = S_1 S_2 \\cdots S_m \\) and \\( t = t_1 t_2 \\cdots t_n \\) with \\( m < n \\). Consider the substring \\( t' = t[1 : m] \\). We have two cases:\n\n1. If \\( S = t' \\), then we set \\( S <_{\\text{Lex}} t \\) because \\( S \\) is shorter than \\( t \\) (e.g., APPLE < APPLET).\n2. Otherwise, \\( S \\neq t' \\). We define \\( S <_{\\text{Lex}} t \\) if \\( S <_{\\text{Lex}} t' \\) and define \\( S >_{\\text{Lex}} t \\) if \\( S >_{\\text{Lex}} t' \\) (e.g., APPLET <_{\\text{Lex}} ARTS because APPL <_{\\text{Lex}} ARTS).\n\n**Given**: A permutation of at most 12 symbols defining an **ordered alphabet** \\( \\mathcal{A} \\) and a positive integer \\( n \\) (\\( n \\leq 4 \\)).\n\n**Return**: All strings of length at most \\( n \\) formed from \\( \\mathcal{A} \\), ordered lexicographically. (Note: As in “Enumerating k-mers Lexicographically”, alphabet order is based on the order in which the symbols are given.)\n\n---\n\n### Sample Dataset\n\n```\nD N A\n3\n```",
    "final_answer": "['D', 'DD', 'DDD', 'DDN', 'DDA', 'DN', 'DND', 'DNN', 'DNA', 'DA', 'DAD', 'DAN', 'DAA', 'N', 'ND', 'NDD', 'NDN', 'NDA', 'NN', 'NND', 'NNN', 'NNA', 'NA', 'NAD', 'NAN', 'NAA', 'A', 'AD', 'ADD', 'ADN', 'ADA', 'AN', 'AND', 'ANN', 'ANA', 'AA', 'AAD', 'AAN', 'AAA']",
    "rationale": "from itertools import product\n\ndef lexicographic_enum(alphabet, n):\n    results = []\n    for i in range(1, n + 1):\n        results.extend([''.join(p) for p in product(alphabet, repeat=i)])\n    return results\n\ndataset = \"\"\"\nD N A\n3\n\"\"\"\n\nlines = dataset.strip().split('\\n')\nalphabet = lines[0].split()\nn = int(lines[1])\n\nresult = lexicographic_enum(alphabet, n)\nresult.sort(key=lambda word: [alphabet.index(c) for c in word])\n\nprint(result)"
  },
  {
    "question": "A **set** is the mathematical term for a loose collection of objects, called **elements**. Examples of sets include \\(\\{\\text{the moon, the sun, Wilford Brimley}\\}\\) and \\(\\mathbb{R}\\), the set containing all real numbers. We even have the **empty set**, represented by \\(\\emptyset\\) or \\(\\{\\}\\), which contains no elements at all. Two sets are equal when they contain the same elements. In other words, in contrast to **permutations**, the ordering of the elements of a set is unimportant (e.g., \\(\\{\\text{the moon, the sun, Wilford Brimley}\\}\\) is equivalent to \\(\\{\\text{Wilford Brimley, the moon, the sun}\\}\\)). Sets are not allowed to contain duplicate elements, so that \\(\\{\\text{Wilford Brimley, the sun, the sun}\\}\\) is not a set. We have already used sets of 2 elements to represent **edges** from a **graph**.\n\nA set \\( A \\) is a **subset** of \\( B \\) if every element of \\( A \\) is also an element of \\( B \\), and we write \\( A \\subseteq B \\). For example, \\(\\{\\text{the sun, the moon}\\} \\subseteq \\{\\text{the sun, the moon, Wilford Brimley}\\}\\), and \\(\\emptyset\\) is a subset of every set (including itself).\n\nAs illustrated in the biological introduction, we can use subsets to represent the collection of taxa possessing a character. However, the number of applications is endless; for example, an **event** in **probability** can now be defined as a subset of the set containing all possible **outcomes**.\n\nOur first question is to count the total number of possible subsets of a given set.\n\n**Given**: A positive integer \\( n \\) (\\( n \\leq 1000 \\)).\n\n**Return**: The total number of subsets of \\(\\{1, 2, \\ldots, n\\}\\) modulo \\( 1,000,000 \\).\n\n---\n\n### Sample Dataset\n\n```\n3\n```",
    "final_answer": "8",
    "rationale": "def total_number_of_subsets(n):\n    modulus = 1000000\n    # Total number of subsets of a set with n elements is 2^n\n    total_subsets = pow(2, n, modulus)\n    return total_subsets\n\nn = 3\nresult = total_number_of_subsets(n)\nprint(result)"
  },
  {
    "question": "Consider a set \\( S \\) of \\( (k+1) \\)-mers of some unknown DNA string. Let \\( S^{\\text{rc}} \\) denote the set containing all reverse complements of the elements of \\( S \\). (Recall from \"Counting Subsets\" that sets are not allowed to contain duplicate elements).\n\nThe **de Bruijn graph** \\( B_k \\) of order \\( k \\) corresponding to \\( S \\cup S^{\\text{rc}} \\) is a digraph defined in the following way:\n\n- Nodes of \\( B_k \\) correspond to all \\( k \\)-mers that are present as a substring of a \\( (k+1) \\)-mer from \\( S \\cup S^{\\text{rc}} \\).\n- Edges of \\( B_k \\) are encoded by the \\( (k+1) \\)-mers of \\( S \\cup S^{\\text{rc}} \\) in the following way: for each \\( (k+1) \\)-mer \\( r \\) in \\( S \\cup S^{\\text{rc}} \\), form a directed edge \\( (r[1:k], r[2:k+1]) \\).\n\nGiven: A collection of up to 1000 (possibly repeating) DNA strings of equal length (not exceeding 50 bp) corresponding to a set \\( S \\) of \\( (k+1) \\)-mers.\n\nReturn: The adjacency list corresponding to the de Bruijn graph corresponding to \\( S \\cup S^{\\text{rc}} \\).\n\nSample Dataset\n\n```\nTGAT\nCATG\nTCAT\nATGC\nCATC\nCATC\n```",
    "final_answer": "[('ATC', 'TCA'), ('ATG', 'TGA'), ('ATG', 'TGC'), ('CAT', 'ATC'), ('CAT', 'ATG'), ('GAT', 'ATG'), ('GCA', 'CAT'), ('TCA', 'CAT'), ('TGA', 'GAT')]",
    "rationale": "from Bio.Seq import Seq\nfrom collections import defaultdict\n\ndef reverse_complement(seq):\n    return str(Seq(seq).reverse_complement())\n\ndef de_bruijn_graph(kmers):\n    adj_list = defaultdict(set)\n    all_kmers = set(kmers)\n\n    for kmer in kmers:\n        all_kmers.add(reverse_complement(kmer))\n    \n    for kmer in all_kmers:\n        adj_list[kmer[:-1]].add(kmer[1:])\n\n    return adj_list\n\ndataset = [\n    \"TGAT\",\n    \"CATG\",\n    \"TCAT\",\n    \"ATGC\",\n    \"CATC\",\n    \"CATC\"\n]\n\ngraph = de_bruijn_graph(dataset)\nresult = sorted([(key, val) for key in graph for val in sorted(graph[key])])\nprint(result)"
  },
  {
    "question": "Consider a collection of coin flips. One of the most natural questions we can ask is if we flip a coin 92 times, what is the **probability** of obtaining 51 \"heads\", vs. 27 \"heads\", vs. 92 \"heads\"?\n\nEach coin flip can be modeled by a **uniform random variable** in which each of the two outcomes (\"heads\" and \"tails\") has probability equal to \\( \\frac{1}{2} \\). We may assume that these random variables are **independent** (see \"Independent Alleles\"); in layman's terms, the outcomes of the two coin flips do not influence each other.\n\nA **binomial random variable** \\( X \\) takes a value of \\( k \\) if \\( n \\) consecutive \"coin flips\" result in \\( k \\) total \"heads\" and \\( n - k \\) total \"tails.\" We write that \\( X \\in \\text{Bin}(n, \\frac{1}{2}) \\).\n\nGiven: A positive integer \\( n \\leq 50 \\).\n\nReturn: An array \\( A \\) of length \\( 2n \\) in which \\( A[k] \\) represents the **common logarithm** of the probability that two diploid siblings share at least \\( k \\) of their \\( 2n \\) chromosomes (we do not consider recombination for now).\n\nSample Dataset\n\n```\n5\n```",
    "final_answer": "[0.0, -0.00042432292765179444, -0.0046905112795315234, -0.024424599331418283, -0.08190410438309813, -0.20547927791864962, -0.423712651968057, -0.7647872888256622, -1.2621119296336116, -1.968907271481587, -3.010299956639812]",
    "rationale": "import math\n\ndef calculate_probabilities(n):\n    total_chromosomes = 2 * n\n    probabilities = []\n    \n    for k in range(total_chromosomes + 1):\n        prob = sum(math.comb(total_chromosomes, i) * (0.5 ** total_chromosomes) for i in range(k, total_chromosomes + 1))\n        probabilities.append(math.log10(prob))\n    \n    return probabilities\n\nn = 5\nresult = calculate_probabilities(n)\nprint(result)"
  },
  {
    "question": "Given a collection of DNA strings representing contigs, we use the N statistic NXX (where XX ranges from 01 to 99) to represent the maximum positive integer L\n such that the total number of nucleotides of all contigs having length ≥L\n is at least XX% of the sum of contig lengths. The most commonly used such statistic is N50, although N75 is also worth mentioning.\n\nGiven: A collection of at most 1000 DNA strings (whose combined length does not exceed 50 kbp).\n\nReturn: N50 and N75 for this collection of strings.\n\nSample Dataset\nGATTACA\nTACTACTAC\nATTGAT\nGAAGA",
    "final_answer": "(7, 6)",
    "rationale": "from Bio import SeqIO\n\ndef calculate_NXX_statistics(contigs, percentage):\n    total_length = sum(len(contig) for contig in contigs)\n    threshold = (percentage * total_length) / 100\n    contigs_sorted = sorted(contigs, key=len, reverse=True)\n    cumulative_length = 0\n    for contig in contigs_sorted:\n        cumulative_length += len(contig)\n        if cumulative_length >= threshold:\n            return len(contig)\n\ncontigs = [\"GATTACA\", \"TACTACTAC\", \"ATTGAT\", \"GAAGA\"]\n\nN50 = calculate_NXX_statistics(contigs, 50)\nN75 = calculate_NXX_statistics(contigs, 75)\n\nresult = (N50, N75)\nprint(result)"
  },
  {
    "question": "As in the case of unrooted trees, say that we have a fixed collection of n\n taxa labeling the leaves of a rooted binary tree T\n. You may like to verify that (by extension of “Counting Phylogenetic Ancestors”) such a tree will contain n−1\n internal nodes and 2n−2\n total edges. Any edge will still encode a split of taxa; however, the two splits corresponding to the edges incident to the root of T\n will be equal. We still consider two trees to be equivalent if they have the same splits (which requires that they must also share the same duplicated split to be equal).\n\nLet B(n)\n represent the total number of distinct rooted binary trees on n\n labeled taxa.\n\nGiven: A positive integer n\n (n≤1000\n).\n\nReturn: The value of B(n)\n modulo 1,000,000.\n\nSample Dataset\n4",
    "final_answer": "15",
    "rationale": "def count_rooted_binary_trees(n):\n    B = [1] * (n + 1)  # Initialize list for storing B(i)\n    for i in range(2, n + 1):\n        B[i] = (B[i - 1] * (2 * i - 3)) % 1000000\n    return B[n]\n\nn = 4\nresult = count_rooted_binary_trees(n)\nprint(result)"
  }
]