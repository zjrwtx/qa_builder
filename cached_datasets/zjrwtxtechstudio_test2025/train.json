{
  "question": [
    "Given: A DNA string s\n of length at most 1000 nt.\n\nReturn: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s\n.\n\nSample Dataset\nAGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC",
    "Given: A DNA string t\n having length at most 1000 nt.\n\nReturn: The transcribed RNA string of t\n.\n\nSample Dataset\nGATGGAACTTGACTACGTAAATT",
    "Given: A DNA string s\n of length at most 1000 bp.\n\nReturn: The reverse complement sc\n of s\n.\n\nSample Dataset\nAAAACCCGGT",
    "A sequence is an ordered collection of objects (usually numbers), which are allowed to repeat. Sequences can be finite or infinite. Two examples are the finite sequence (π,−2–√,0,π)\n and the infinite sequence of odd numbers (1,3,5,7,9,…)\n. We use the notation an\n to represent the n\n-th term of a sequence.\n\nA recurrence relation is a way of defining the terms of a sequence with respect to the values of previous terms. In the case of Fibonacci's rabbits from the introduction, any given month will contain the rabbits that were alive the previous month, plus any new offspring. A key observation is that the number of offspring in any month is equal to the number of rabbits that were alive two months prior. As a result, if Fn\n represents the number of rabbit pairs alive after the n\n-th month, then we obtain the Fibonacci sequence having terms Fn\n that are defined by the recurrence relation Fn=Fn−1+Fn−2\n (with F1=F2=1\n to initiate the sequence). Although the sequence bears Fibonacci's name, it was known to Indian mathematicians over two millennia ago.\n\nWhen finding the n\n-th term of a sequence defined by a recurrence relation, we can simply use the recurrence relation to generate terms for progressively larger values of n\n. This problem introduces us to the computational technique of dynamic programming, which successively builds up solutions by using the answers to smaller cases.\n\nGiven: Positive integers n≤40\n and k≤5\n.\n\nReturn: The total number of rabbit pairs that will be present after n\n months, if we begin with 1 pair and in each generation, every pair of reproduction-age rabbits produces a litter of k\n rabbit pairs (instead of only 1 pair).\n\nSample Dataset\n5 3",
    "Given: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).\n\nReturn: The ID of the string having the highest GC-content, followed by the GC-content of that string. Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated; please see the note on absolute error below.\n\nSample Dataset\n>Rosalind_0808\nCCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC\nTGGGAACCTGCGGGCAGTAGGTGGAAT",
    "Given two strings s\n and t\n of equal length, the Hamming distance between s\n and t\n, denoted dH(s,t)\n, is the number of corresponding symbols that differ in s\n and t\n\nGiven: Two DNA strings s\n and t\n of equal length (not exceeding 1 kbp).\n\nReturn: The Hamming distance dH(s,t)\n.\n\nSample Dataset\nGAGCCTACTAACGGGAT\nCATCGTAATGACGGCCT",
    "Given: Three positive integers k\n, m\n, and n\n, representing a population containing k+m+n\n organisms: k\n individuals are homozygous dominant for a factor, m\n are heterozygous, and n\n are homozygous recessive.\n\nReturn: The probability that two randomly selected mating organisms will produce an individual possessing a dominant allele (and thus displaying the dominant phenotype). Assume that any two organisms can mate.\n\nSample Dataset\n2 2 2",
    "Problem\nThe 20 commonly occurring amino acids are abbreviated by using 20 letters from the English alphabet (all letters except for B, J, O, U, X, and Z). Protein strings are constructed from these 20 symbols. Henceforth, the term genetic string will incorporate protein strings along with DNA strings and RNA strings.\n\nThe RNA codon table dictates the details regarding the encoding of specific codons into the amino acid alphabet.\n\nGiven: An RNA string s\n corresponding to a strand of mRNA (of length at most 10 kbp).\n\nReturn: The protein string encoded by s\n.\n\nSample Dataset\nAUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA",
    "For DNA strings of a given length, their transition/transversion ratio $R(s_1, s_2)$ is the ratio of the total number of transitions to the total number of transversions, where symbol substitutions are inferred from mismatches of corresponding symbols as when calculating Hamming distance (see \"Counting Point Mutations\").\n\n**Given**: Two DNA strings $s_1$ and $s_2$ of equal length (at most 1 kbp).\n\n**Return**: The transition/transversion ratio $R(s_1, s_2)$.\n\n>Rosalind_0209\nGCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGA\nAGTACGGGCATCAACCCAGTT\n>Rosalind_2200\nTTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGC\nGGTACGAGTGTTCCTTTGGGT",
    "As is the case with point mutations, the most common type of sequencing error occurs when a single nucleotide from a read is interpreted incorrectly.\n\nGiven: A collection of up to 1000 reads of equal length (at most 50 bp) in FASTA format. Some of these reads were generated with a single-nucleotide error. For each read s\n in the dataset, one of the following applies:\n\ns\n was correctly sequenced and appears in the dataset at least twice (possibly as a reverse complement);\ns\n is incorrect, it appears in the dataset exactly once, and its Hamming distance is 1 with respect to exactly one correct read in the dataset (or its reverse complement).\nReturn: A list of all corrections in the form \"[old read]->[new read]\". (Each correction must be a single symbol substitution, and you may return the corrections in any order.)\nSample Dataset\n>Rosalind_52\nTCATC\n>Rosalind_44\nTTCAT\n>Rosalind_68\nTCATC\n>Rosalind_28\nTGAAA\n>Rosalind_95\nGAGGA\n>Rosalind_66\nTTTCA\n>Rosalind_33\nATCAA\n>Rosalind_21\nTTGAT\n>Rosalind_18\nTTTCC",
    "A binary tree is a tree in which each node has degree equal to at most 3. The binary tree will be our main tool in the construction of phylogenies.\n\nA rooted tree is a tree in which one node (the root) is set aside to serve as the pinnacle of the tree. A standard graph theory exercise is to verify that for any two nodes of a tree, exactly one path connects the nodes. In a rooted tree, every node v\n will therefore have a single parent, or the unique node w\n such that the path from v\n to the root contains {v,w}\n. Any other node x\n adjacent to v\n is called a child of v\n because v\n must be the parent of x\n; note that a node may have multiple children. In other words, a rooted tree possesses an ordered hierarchy from the root down to its leaves, and as a result, we may often view a rooted tree with undirected edges as a directed graph in which each edge is oriented from parent to child. We should already be familiar with this idea; it's how the Rosalind problem tree works!\n\nEven though a binary tree can include nodes having degree 2, an unrooted binary tree is defined more specifically: all internal nodes have degree 3. In turn, a rooted binary tree is such that only the root has degree 2 (all other internal nodes have degree 3).\n\nGiven: A positive integer n\n (3≤n≤10000\n).\n\nReturn: The number of internal nodes of any unrooted binary tree having n\n leaves.\n\nSample Dataset\n4\n",
    "For a fixed positive integer k\n, order all possible k-mers taken from an underlying alphabet lexicographically.\n\nThen the k-mer composition of a string s\n can be represented by an array A\n for which A[m]\n denotes the number of times that the m\nth k-mer (with respect to the lexicographic order) appears in s\n.\n\nGiven: A DNA string s\n in FASTA format (having length at most 100 kbp).\n\nReturn: The 4-mer composition of s\n.\n\nSample Dataset\n>Rosalind_6431\nCTTCGAAAGTTTGGGCCGAGTCTTACAGTCGGTCTTGAAGCAAAGTAACGAACTCCACGG\nCCCTGACTACCGAACCAGTTGTGAGTACTCAACTGGGTGAGAGTGCAGTCCCTATTGAGT\nTTCCGAGACTCACCGGGATTTTCGATCCAGCCTCAGTCCAGTCTTGTGGCCAACTCACCA\nAATGACGTTGGAATATCCCTGTCTAGCTCACGCAGTACTTAGTAAGAGGTCGCTGCAGCG\nGGGCAAGGAGATCGGAAAATGTGCTCTATATGCGACTAAAGCTCCTAACTTACACGTAGA\nCTTGCCCGTGTTAAAAACTCGGCTCACATGCTGTCTGCGGCTGGCTGTATACAGTATCTA\nCCTAATACCCTTCAGTTCGCCGCACAAAAGCTGGGAGTTACCGCGGAAATCACAG",
    "A **prefix** of a length \\( n \\) string \\( S \\) is a substring \\( s[1 : j] \\); a **suffix** of \\( S \\) is a substring \\( s[k : n] \\).\n\nThe **failure array** of \\( S \\) is an **array** \\( P \\) of length \\( n \\) for which \\( P[k] \\) is the length of the longest substring \\( s[j : k] \\) that is equal to some prefix \\( s[1 : k - j + 1] \\), where \\( j \\) cannot equal 1 (otherwise, \\( P[k] \\) would always equal \\( k \\)). By convention, \\( P[1] = 0 \\).\n\n**Given**: A **DNA string** \\( S \\) (of length at most 100 kbp) in **FASTA format**.\n\n**Return**: The failure array of \\( S \\).\nSample Dataset\n>Rosalind_87\nCAGCATGGTATCACAGCAGAG",
    "A string u\n is a common subsequence of strings s\n and t\n if the symbols of u\n appear in order as a subsequence of both s\n and t\n. For example, \"ACTG\" is a common subsequence of \"AACCTTGG\" and \"ACACTGTGA\".\n\nAnalogously to the definition of longest common substring, u\n is a longest common subsequence of s\n and t\n if there does not exist a longer common subsequence of the two strings. Continuing our above example, \"ACCTTG\" is a longest common subsequence of \"AACCTTGG\" and \"ACACTGTGA\", as is \"AACTGG\".\n\nGiven: Two DNA strings s\n and t\n (each having length at most 1 kbp) in FASTA format.\n\nReturn: A longest common subsequence of s\n and t\n. (If more than one solution exists, you may return any one.)\n\nSample Dataset\n>Rosalind_23\nAACCTTGG\n>Rosalind_64\nACACTGTGA",
    "### Problem\n\nSay that we have strings \\( S = S_1 S_2 \\cdots S_m \\) and \\( t = t_1 t_2 \\cdots t_n \\) with \\( m < n \\). Consider the substring \\( t' = t[1 : m] \\). We have two cases:\n\n1. If \\( S = t' \\), then we set \\( S <_{\\text{Lex}} t \\) because \\( S \\) is shorter than \\( t \\) (e.g., APPLE < APPLET).\n2. Otherwise, \\( S \\neq t' \\). We define \\( S <_{\\text{Lex}} t \\) if \\( S <_{\\text{Lex}} t' \\) and define \\( S >_{\\text{Lex}} t \\) if \\( S >_{\\text{Lex}} t' \\) (e.g., APPLET <_{\\text{Lex}} ARTS because APPL <_{\\text{Lex}} ARTS).\n\n**Given**: A permutation of at most 12 symbols defining an **ordered alphabet** \\( \\mathcal{A} \\) and a positive integer \\( n \\) (\\( n \\leq 4 \\)).\n\n**Return**: All strings of length at most \\( n \\) formed from \\( \\mathcal{A} \\), ordered lexicographically. (Note: As in “Enumerating k-mers Lexicographically”, alphabet order is based on the order in which the symbols are given.)\n\n---\n\n### Sample Dataset\n\n```\nD N A\n3\n```",
    "The **graph theoretical** analogue of the quandary stated in the introduction above is that if we have an **RNA string** \\( S \\) that does not have the same number of occurrences of 'C' as 'G' and the same number of occurrences of 'A' as 'U', then the **bonding graph** of \\( S \\) cannot possibly possess a **perfect matching** among its **basepair edges**. For example, see **Figure 1**; in fact, most bonding graphs will not contain a perfect matching.\n\nIn light of this fact, we define a **maximum matching** in a graph as a **matching** containing as many **edges** as possible. See **Figure 2** for three maximum matchings in graphs.\n\nA maximum matching of basepair edges will correspond to a way of forming as many base pairs as possible in an RNA string, as shown in **Figure 3**.\n\n**Given**: An RNA string \\( S \\) of length at most 100.\n\n**Return**: The total possible number of maximum matchings of basepair edges in the bonding graph of \\( S \\).\n\n---\n\n### Sample Dataset\n\n```\n>Rosalind_92\nAUGCUUC\n```",
    "0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000",
    "For two **strings** \\( S_1 \\) and \\( S_2 \\) of equal length, the **p-distance** between them, denoted \\( d_p(S_1, S_2) \\), is the proportion of corresponding symbols that differ between \\( S_1 \\) and \\( S_2 \\).\n\nFor a general distance function \\( d \\) on \\( n \\) taxa \\( S_1, S_2, \\ldots, S_n \\) (taxa are often represented by **genetic strings**), we may encode the distances between pairs of taxa via a **distance matrix** \\( D \\) in which \\( D_{i,j} = d(S_i, S_j) \\).\n\n**Given**: A collection of \\( n \\) (\\( n \\leq 10 \\)) **DNA strings** \\( S_1, \\ldots, S_n \\) of equal length (at most 1 kbp). Strings are given in **FASTA format**.\n\n**Return**: The matrix \\( D \\) corresponding to the p-distance \\( d_p \\) on the given strings. As always, note that your answer is allowed an **absolute error** of 0.001.\n\n---\n\n### Sample Dataset\n\n```\n>Rosalind_9499\nTTTCCATTTA\n>Rosalind_0942\nGATTCA TTC\n>Rosalind_6568\nTTTCCATTTT\n>Rosalind_1833\nGTTCCATTTA\n```",
    "### Problem\n\nOur aim in this problem is to determine the **probability** with which a given motif (a known promoter, say) occurs in a randomly constructed genome. Unfortunately, finding this probability is tricky; instead of forming a long genome, we will form a large collection of smaller **random strings** having the same length as the motif; these smaller strings represent the genome's **substrings**, which we can then test against our motif.\n\nGiven a **probabilistic event** \\( A \\), the **complement** of \\( A \\) is the collection \\( A^c \\) of outcomes not belonging to \\( A \\). Because \\( A^c \\) takes place precisely when \\( A \\) does not, we may also call \\( A^c \\) \"not \\( A \\).\" For a simple example, if \\( A \\) is the event that a rolled die is 2 or 4, then \\( \\text{Pr}(A) = \\frac{1}{3} \\). \\( A^c \\) is the event that the die is 1, 3, 5, or 6, and \\( \\text{Pr}(A^c) = \\frac{2}{3} \\). In general, for any event we will have the identity that \\( \\text{Pr}(A) + \\text{Pr}(A^c) = 1 \\).\n\n**Given**: A positive integer \\( N \\leq 100000 \\), a number \\( X \\) between 0 and 1, and a DNA string \\( S \\) of length at most 10 bp.\n\n**Return**: The probability that if \\( N \\) random DNA strings having the same length as \\( S \\) are constructed with **GC-content** \\( X \\) (see \"Introduction to Random Strings\"), then at least one of the strings equals \\( S \\). We allow for the same random string to be created more than once.\n\n---\n\n### Sample Dataset\n\n```\n90000 0.6\nATAGCCGA\n```",
    "A **set** is the mathematical term for a loose collection of objects, called **elements**. Examples of sets include \\(\\{\\text{the moon, the sun, Wilford Brimley}\\}\\) and \\(\\mathbb{R}\\), the set containing all real numbers. We even have the **empty set**, represented by \\(\\emptyset\\) or \\(\\{\\}\\), which contains no elements at all. Two sets are equal when they contain the same elements. In other words, in contrast to **permutations**, the ordering of the elements of a set is unimportant (e.g., \\(\\{\\text{the moon, the sun, Wilford Brimley}\\}\\) is equivalent to \\(\\{\\text{Wilford Brimley, the moon, the sun}\\}\\)). Sets are not allowed to contain duplicate elements, so that \\(\\{\\text{Wilford Brimley, the sun, the sun}\\}\\) is not a set. We have already used sets of 2 elements to represent **edges** from a **graph**.\n\nA set \\( A \\) is a **subset** of \\( B \\) if every element of \\( A \\) is also an element of \\( B \\), and we write \\( A \\subseteq B \\). For example, \\(\\{\\text{the sun, the moon}\\} \\subseteq \\{\\text{the sun, the moon, Wilford Brimley}\\}\\), and \\(\\emptyset\\) is a subset of every set (including itself).\n\nAs illustrated in the biological introduction, we can use subsets to represent the collection of taxa possessing a character. However, the number of applications is endless; for example, an **event** in **probability** can now be defined as a subset of the set containing all possible **outcomes**.\n\nOur first question is to count the total number of possible subsets of a given set.\n\n**Given**: A positive integer \\( n \\) (\\( n \\leq 1000 \\)).\n\n**Return**: The total number of subsets of \\(\\{1, 2, \\ldots, n\\}\\) modulo \\( 1,000,000 \\).\n\n---\n\n### Sample Dataset\n\n```\n3\n```",
    "### Problem\n\nGiven two **strings** \\( S \\) and \\( t \\) (of possibly different lengths), the **edit distance** \\( d_E(S, t) \\) is the minimum number of **edit operations** needed to transform \\( S \\) into \\( t \\), where an edit operation is defined as the substitution, insertion, or deletion of a single symbol.\n\nThe latter two operations **incorporate** the case in which a contiguous interval is inserted into or deleted from a string; such an interval is called a **gap**. For the purposes of this problem, the insertion or deletion of a gap of length \\( k \\) still counts as \\( k \\) distinct edit operations.\n\n**Given**: Two **protein strings** \\( S \\) and \\( t \\) in **FASTA format** (each of length at most 1000 aa).\n\n**Return**: The edit distance \\( d_E(S, t) \\).\n\n---\n\n### Sample Dataset\n\n```\n>Rosalind_39\nPLEASANTLY\n>Rosalind_11\nMEANLY\n```",
    "Say that you place a number of bets on your favorite sports teams. If their chances of winning are 0.3, 0.8, and 0.6, then you should expect on average to win 0.3 + 0.8 + 0.6 = 1.7 of your bets (of course, you can never win exactly 1.7!)\n\nMore generally, if we have a collection of events \\( A_1, A_2, \\ldots, A_n \\), then the expected number of events occurring is \\( \\Pr(A_1) + \\Pr(A_2) + \\cdots + \\Pr(A_n) \\) (consult the note following the problem for a precise explanation of this fact). In this problem, we extend the idea of finding an expected number of events to finding the expected number of times that a given string occurs as a substring of a random string.\n\nGiven: A positive integer \\( n \\) (\\( n \\leq 1,000,000 \\)), a DNA string \\( S \\) of even length at most 10, and an array \\( A \\) of length at most 20, containing numbers between 0 and 1.\n\nReturn: An array \\( B \\) having the same length as \\( A \\) in which \\( B[i] \\) represents the expected number of times that \\( S \\) will appear as a substring of a random DNA string \\( t \\) of length \\( n \\), where \\( t \\) is formed with GC-content \\( A[i] \\) (see “Introduction to Random Strings”).\n\nSample Dataset\n\n```\n10\nAG\n0.25 0.5 0.75\n```",
    "Similarly to our definition of the Catalan numbers, the \\( n \\)-th Motzkin number \\( m_n \\) counts the number of ways to form a (not necessarily perfect) noncrossing matching in the complete graph \\( K_n \\) containing \\( n \\) nodes. For example, Figure 1 demonstrates that \\( m_6 = 21 \\). Note in this figure that technically, the \"trivial\" matching that contains no edges at all is considered to be a matching, because it satisfies the defining condition that no two edges are incident to the same node.\n\nHow should we compute the Motzkin numbers? As with Catalan numbers, we will take \\( m_0 = m_1 = 1 \\). To calculate \\( m_n \\) in general, assume that the nodes of \\( K_n \\) are labeled around the outside of a circle with the integers between 1 and \\( n \\), and consider node 1, which may or may not be involved in a matching. If node 1 is not involved in a matching, then there are \\( m_{n-1} \\) ways of matching the remaining \\( n-1 \\) nodes. If node 1 is involved in a matching, then say it is matched to node \\( k \\): this leaves \\( k-2 \\) nodes on one side of edge \\( \\{1, k\\} \\) and \\( n-k \\) nodes on the other side; as with the Catalan numbers, no edge can connect the two sides, which gives us \\( m_{k-2} \\cdot m_{n-k} \\) ways of matching the remaining edges. Allowing \\( k \\) to vary between 2 and \\( n \\) yields the following recurrence relation for the Motzkin numbers: \\( m_n = m_{n-1} + \\sum_{k=2}^n m_{k-2} \\cdot m_{n-k} \\).\n\nTo count all possible secondary structures of a given RNA string that do not contain pseudoknots, we need to modify the Motzkin recurrence so that it counts only matchings of basepair edges in the bonding graph corresponding to the RNA string; see Figure 2.\n\nGiven: An RNA string \\( S \\) of length at most 300 bp.\n\nReturn: The total number of noncrossing matchings of basepair edges in the bonding graph of \\( S \\), modulo 1,000,000.\n\nSample Dataset\n\n```\n>Rosalind_57\nAUAU\n```",
    "Newick format is a way of representing trees even more concisely than using an adjacency list, especially when dealing with trees whose internal nodes have not been labeled.\n\nFirst, consider the case of a rooted tree \\( T \\). A collection of leaves \\( V_1, V_2, \\ldots, V_n \\) of \\( T \\) are neighbors if they are all adjacent to some internal node \\( U \\). Newick format for \\( T \\) is obtained by iterating the following key step: delete all the edges \\( \\{V_i, U\\} \\) from \\( T \\) and label \\( U \\) with \\( (V_1, V_2, \\ldots, V_n)U \\). This process is repeated all the way to the root, at which point a semicolon signals the end of the tree.\n\nA number of variations of Newick format exist. First, if a node is not labeled in \\( T \\), then we simply leave blank the space occupied by the node. In the key step, we can write \\( (V_1, V_2, \\ldots, V_n) \\) in place of \\( (V_1, V_2, \\ldots, V_n)U \\) if the \\( V_i \\) are labeled; if none of the nodes are labeled, we can write \\( (, , \\ldots, ) \\).\n\nA second variation of Newick format occurs when \\( T \\) is unrooted, in which case we simply select any internal node to serve as the root of \\( T \\). A particularly peculiar case of Newick format arises when we choose a leaf to serve as the root.\n\nNote that there will be a large number of different ways to represent \\( T \\) in Newick format; see Figure 1.\n\nGiven: A collection of \\( n \\) trees (\\( n \\leq 40 \\)) in Newick format, with each tree containing at most 200 nodes; each tree \\( T_k \\) is followed by a pair of nodes \\( x_k \\) and \\( y_k \\) in \\( T_k \\).\n\nReturn: A collection of \\( n \\) positive integers, for which the \\( k \\)-th integer represents the distance between \\( x_k \\) and \\( y_k \\) in \\( T_k \\).\n\nSample Dataset\n\n```\n(cat)dog;\ndog cat\n\n(dog,cat);\ndog cat\n```",
    "A string s\n is a supersequence of another string t\n if s\n contains t\n as a subsequence.\n\nA common supersequence of strings s\n and t\n is a string that serves as a supersequence of both s\n and t\n. For example, \"GACCTAGGAACTC\" serves as a common supersequence of \"ACGTC\" and \"ATAT\". A shortest common supersequence of s\n and t\n is a supersequence for which there does not exist a shorter common supersequence. Continuing our example, \"ACGTACT\" is a shortest common supersequence of \"ACGTC\" and \"ATAT\".\n\nGiven: Two DNA strings s\n and t\n.\n\nReturn: A shortest common supersequence of s\n and t\n. If multiple solutions exist, you may output any one.\n\nSample Dataset\nATCTGAT\nTGCATA",
    "A reversal of a permutation can be encoded by the two indices at the endpoints of the interval that it inverts; for example, the reversal that transforms \\( (4, 1, 2, 6, 3, 5) \\) into \\( (4, 1, 3, 6, 2, 5) \\) is encoded by \\( [3, 5] \\).\n\nA collection of reversals sorts \\( \\Pi \\) into \\( \\gamma \\) if the collection contains \\( d_{\\text{rev}}(\\Pi, \\gamma) \\) reversals, which when successively applied to \\( \\Pi \\) yield \\( \\gamma \\).\n\nGiven: Two permutations \\( \\Pi \\) and \\( \\gamma \\), each of length 10.\n\nReturn: The reversal distance \\( d_{\\text{rev}}(\\Pi, \\gamma) \\), followed by a collection of reversals sorting \\( \\Pi \\) into \\( \\gamma \\). If multiple collections of such reversals exist, you may return any one.\n\nSample Dataset\n\n```\n1 2 3 4 5 6 7 8 9 10\n1 8 9 3 2 7 6 5 4 10\n```",
    "The prefix spectrum of a weighted string is the collection of all its prefix weights.\n\nGiven: A list L\n of n\n (n≤100\n) positive real numbers.\n\nReturn: A protein string of length n−1\n whose prefix spectrum is equal to L\n (if multiple solutions exist, you may output any one of them). Consult the monoisotopic mass table.\n\nSample Dataset\n3524.8542\n3710.9335\n3841.974\n3970.0326\n4057.0646",
    "Given a collection of strings, their trie (often pronounced \"try\" to avoid ambiguity with the general term tree) is a rooted tree formed as follows. For every unique first symbol in the strings, an edge is formed connecting the root to a new vertex. This symbol is then used to label the edge.\n\nWe may then iterate the process by moving down one level as follows. Say that an edge connecting the root to a node \\( V \\) is labeled with 'A'; then we delete the first symbol from every string in the collection beginning with 'A' and then treat \\( V \\) as our root. We apply this process to all nodes that are adjacent to the root, and then we move down another level and continue. See Figure 1 for an example of a trie.\n\nAs a result of this method of construction, the symbols along the edges of any path in the trie from the root to a leaf will spell out a unique string from the collection, as long as no string is a prefix of another in the collection (this would cause the first string to be encoded as a path terminating at an internal node).\n\nGiven: A list of at most 100 DNA strings of length at most 100 bp, none of which is a prefix of another.\n\nReturn: The adjacency list corresponding to the trie \\( T \\) for these patterns, in the following format. If \\( T \\) has \\( n \\) nodes, first label the root with 1 and then label the remaining nodes with the integers 2 through \\( n \\) in any order you like. Each edge of the adjacency list of \\( T \\) will be encoded by a triple containing the integer representing the edge's parent node, followed by the integer representing the edge's child node, and finally the symbol labeling the edge.\n\nSample Dataset\n\n```\nATAGA\nATC\nGAT\n```",
    "A **multiset** is a generalization of the notion of **set** to include a collection of objects in which each object may occur more than once (the order in which objects are given is still unimportant). For a multiset \\( S \\), the **multiplicity** of an element \\( X \\) is the number of times that \\( X \\) occurs in the set; this multiplicity is denoted \\( S(X) \\). Note that every set is included in the definition of multiset.\n\nThe **Minkowski sum** of multisets \\( S_1 \\) and \\( S_2 \\) containing real numbers is the new multiset \\( S_1 \\oplus S_2 \\) formed by taking all possible sums \\( s_1 + s_2 \\) of an element \\( s_1 \\) from \\( S_1 \\) and an element \\( s_2 \\) from \\( S_2 \\). The Minkowski sum could be defined more concisely as \\( S_1 \\oplus S_2 = \\{s_1 + s_2 : s_1 \\in S_1, s_2 \\in S_2\\} \\). The **Minkowski difference** \\( S_1 \\ominus S_2 \\) is defined analogously by taking all possible differences \\( s_1 - s_2 \\).\n\nIf \\( S_1 \\) and \\( S_2 \\) represent simplified spectra taken from two peptides, then \\( S_1 \\ominus S_2 \\) is called the **spectral convolution** of \\( S_1 \\) and \\( S_2 \\). In this notation, the shared peaks count is represented by \\( (S_2 \\ominus S_1)(0) \\), and the value of \\( x \\) for which \\( (S_2 \\ominus S_1)(x) \\) has the maximal value is the shift value maximizing the number of shared masses of \\( S_1 \\) and \\( S_2 \\).\n\nGiven: Two multisets of positive real numbers \\( S_1 \\) and \\( S_2 \\). The size of each multiset is at most 200.\n\nReturn: The largest multiplicity of \\( S_1 \\ominus S_2 \\), as well as the absolute value of the number \\( x \\) maximizing \\( (S_1 \\ominus S_2)(x) \\) (you may return any such value if multiple solutions exist).\n\nSample Dataset\n\n```\n186.07931 287.12699 548.20532 580.18077 681.22845 706.27446 782.27613 968.35544 968.35544\n101.04768 158.06914 202.09536 318.09979 419.14747 463.17369\n```",
    "Given a collection of \\( N \\) taxa, any subset \\( S \\) of these taxa can be seen as encoding a character that divides the taxa into the sets \\( S \\) and \\( S^c \\); we can represent the character by \\( S \\mid S^c \\), which is called a **split**. Alternately, the character can be represented by a **character array** \\( A \\) of length \\( N \\) for which \\( A[j] = 1 \\) if the \\( j \\)-th taxon belongs to \\( S \\) and \\( A[j] = 0 \\) if the \\( j \\)-th taxon belongs to \\( S^c \\) (recall the \"ON\"/\"OFF\" analogy from \"Counting Subsets\").\n\nAt the same time, observe that the removal of an edge from an **unrooted binary tree** produces two separate trees, each one containing a subset of the original taxa. So each edge may also be encoded by a split \\( S \\mid S^c \\).\n\nA **trivial character** isolates a single taxon into a group of its own. The corresponding split \\( S \\mid S^c \\) must be such that \\( S \\) or \\( S^c \\) contains only one element; the edge encoded by this split must be incident to a leaf of the unrooted binary tree, and the array for the character contains exactly one 0 or exactly one 1. Trivial characters are of no phylogenetic interest because they fail to provide us with information regarding the relationships of taxa to each other. All other characters are called **nontrivial characters** (and the associated splits are called **nontrivial splits**).\n\nA **character table** is a matrix \\( C \\) in which each row represents the array notation for a nontrivial character. That is, entry \\( C_{i,j} \\) denotes the \"ON\"/\"OFF\" position of the \\( i \\)-th character with respect to the \\( j \\)-th taxon.\n\nGiven: An unrooted binary tree \\( T \\) in **Newick format** for at most 200 species taxa.\n\nReturn: A character table having the same splits as the edge splits of \\( T \\). The columns of the character table should encode the taxa ordered lexicographically; the rows of the character table may be given in any order. Also, for any given character, the particular subset of taxa to which 1s are assigned is arbitrary.\n\nSample Dataset\n\n```\n(dog,((elephant,mouse),robot),cat);\n```",
    "Consider a set \\( S \\) of \\( (k+1) \\)-mers of some unknown DNA string. Let \\( S^{\\text{rc}} \\) denote the set containing all reverse complements of the elements of \\( S \\). (Recall from \"Counting Subsets\" that sets are not allowed to contain duplicate elements).\n\nThe **de Bruijn graph** \\( B_k \\) of order \\( k \\) corresponding to \\( S \\cup S^{\\text{rc}} \\) is a digraph defined in the following way:\n\n- Nodes of \\( B_k \\) correspond to all \\( k \\)-mers that are present as a substring of a \\( (k+1) \\)-mer from \\( S \\cup S^{\\text{rc}} \\).\n- Edges of \\( B_k \\) are encoded by the \\( (k+1) \\)-mers of \\( S \\cup S^{\\text{rc}} \\) in the following way: for each \\( (k+1) \\)-mer \\( r \\) in \\( S \\cup S^{\\text{rc}} \\), form a directed edge \\( (r[1:k], r[2:k+1]) \\).\n\nGiven: A collection of up to 1000 (possibly repeating) DNA strings of equal length (not exceeding 50 bp) corresponding to a set \\( S \\) of \\( (k+1) \\)-mers.\n\nReturn: The adjacency list corresponding to the de Bruijn graph corresponding to \\( S \\cup S^{\\text{rc}} \\).\n\nSample Dataset\n\n```\nTGAT\nCATG\nTCAT\nATGC\nCATC\nCATC\n```",
    "An **alignment** of two strings \\( S \\) and \\( t \\) is defined by two strings \\( S' \\) and \\( t' \\) satisfying the following three conditions:\n\n1. \\( S' \\) and \\( t' \\) must be formed from adding **gap symbols** \"-\" to each of \\( S \\) and \\( t \\), respectively; as a result, \\( S \\) and \\( t \\) will form subsequences of \\( S' \\) and \\( t' \\).\n2. \\( S' \\) and \\( t' \\) must have the same length.\n3. Two gap symbols may not be aligned; that is, if \\( S'[j] \\) is a gap symbol, then \\( t'[j] \\) cannot be a gap symbol, and vice-versa.\n\nWe say that \\( S' \\) and \\( t' \\) **augment** \\( S \\) and \\( t \\). Writing \\( S' \\) directly over \\( t' \\) so that symbols are **aligned** provides us with a scenario for transforming \\( S \\) into \\( t \\). Mismatched symbols from \\( S \\) and \\( t \\) correspond to symbol substitutions; a gap symbol \\( S'[j] \\) aligned with a non-gap symbol \\( t'[j] \\) implies the insertion of this symbol into \\( t \\); a gap symbol \\( t'[j] \\) aligned with a non-gap symbol \\( S'[j] \\) implies the deletion of this symbol from \\( S \\).\n\nThus, an alignment represents a transformation of \\( S \\) into \\( t \\) via edit operations. We define the corresponding **edit alignment score** of \\( S' \\) and \\( t' \\) as \\( d_H(S', t') \\) (Hamming distance is used because the gap symbol has been introduced for insertions and deletions). It follows that \\( d_E(S, t) = \\min_{S', t'} d_H(S', t') \\), where the minimum is taken over all alignments of \\( S \\) and \\( t \\). We call such a minimum score alignment an **optimal alignment** (with respect to edit distance).\n\nGiven: Two **protein strings** \\( S \\) and \\( t \\) in FASTA format (with each string having length at most 1000 aa).\n\nReturn: The edit distance \\( d_E(S, t) \\) followed by two augmented strings \\( S' \\) and \\( t' \\) representing an optimal alignment of \\( S \\) and \\( t \\).\n\nSample Dataset\n\n```\n>Rosalind_43\nPRETTY\n>Rosalind_97\nPRTTEIN\n```",
    "Say that we have a string \\( S \\) containing \\( t \\) as an internal substring, so that there exist nonempty substrings \\( S_1 \\) and \\( S_2 \\) of \\( S \\) such that \\( S \\) can be written as \\( S_1 t S_2 \\). A **t-prefix** contains all of \\( S_1 \\) and none of \\( S_2 \\); likewise, a **t-suffix** contains all of \\( S_2 \\) and none of \\( S_1 \\).\n\nGiven: A list \\( L \\) containing \\( 2n + 3 \\) positive real numbers (\\( n \\leq 100 \\)). The first number in \\( L \\) is the parent mass of a peptide \\( P \\), and all other numbers represent the masses of some b-ions and y-ions of \\( P \\) (in no particular order). You may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.\n\nReturn: A protein string \\( t \\) of length \\( n \\) for which there exist two positive real numbers \\( W_1 \\) and \\( W_2 \\) such that for every prefix \\( p \\) and suffix \\( s \\) of \\( t \\), each of \\( w(p) + W_1 \\) and \\( w(s) + W_2 \\) is equal to an element of \\( L \\). (In other words, there exists a protein string whose t-prefix and t-suffix weights correspond to the non-parent mass values of \\( L \\).) If multiple solutions exist, you may output any one.\n\nSample Dataset\n\n```\n1988.21104821\n610.391039105\n738.485999105\n766.492149105\n863.544909105\n867.528589105\n992.587499105\n995.623549105\n1120.6824591\n1124.6661391\n1221.7188991\n1249.7250491\n1377.8200091\n```",
    "Consider a collection of coin flips. One of the most natural questions we can ask is if we flip a coin 92 times, what is the **probability** of obtaining 51 \"heads\", vs. 27 \"heads\", vs. 92 \"heads\"?\n\nEach coin flip can be modeled by a **uniform random variable** in which each of the two outcomes (\"heads\" and \"tails\") has probability equal to \\( \\frac{1}{2} \\). We may assume that these random variables are **independent** (see \"Independent Alleles\"); in layman's terms, the outcomes of the two coin flips do not influence each other.\n\nA **binomial random variable** \\( X \\) takes a value of \\( k \\) if \\( n \\) consecutive \"coin flips\" result in \\( k \\) total \"heads\" and \\( n - k \\) total \"tails.\" We write that \\( X \\in \\text{Bin}(n, \\frac{1}{2}) \\).\n\nGiven: A positive integer \\( n \\leq 50 \\).\n\nReturn: An array \\( A \\) of length \\( 2n \\) in which \\( A[k] \\) represents the **common logarithm** of the probability that two diploid siblings share at least \\( k \\) of their \\( 2n \\) chromosomes (we do not consider recombination for now).\n\nSample Dataset\n\n```\n5\n```",
    "Given three strings \\( S \\), \\( t \\), and \\( u \\), we say that \\( t \\) and \\( u \\) can be **interwoven** into \\( S \\) if there is some substring of \\( S \\) made up of \\( t \\) and \\( u \\) as disjoint subsequences.\n\nFor example, the strings \"ACAG\" and \"CCG\" can be interwoven into \"GACCACGGTT\". However, they cannot be interwoven into \"GACCACAAAAGGT\" because of the appearance of the four 'A's in the middle of the subsequences. Similarly, even though both \"ACACG\" is a shortest common supersequence of ACAG and CCG, it is not possible to interweave these two strings into \"ACACG\" because the two desired subsequences must be disjoint; see \"Interleaving Two Motifs\" for details on finding a shortest common supersequence of two strings.\n\nGiven: A text DNA string \\( S \\) of length at most 10 kbp, followed by a collection of \\( n \\) (\\( n \\leq 10 \\)) DNA strings of length at most 10 bp acting as patterns.\n\nReturn: An \\( n \\times n \\) matrix \\( M \\) for which \\( M_{j,k} = 1 \\) if the \\( j \\)-th and \\( k \\)-th pattern strings can be interwoven into \\( S \\) and \\( M_{j,k} = 0 \\) otherwise.\n\nSample Dataset\n\n```\nGACCACGGTT\nACAG\nGT\nCCG\n```",
    "A **repeated substring** of a string \\( S \\) of length \\( n \\) is simply a substring that appears in more than one location of \\( S \\); more specifically, a **k-fold substring** appears in at least \\( k \\) distinct locations.\n\nThe **suffix tree** of \\( S \\), denoted \\( T(S) \\), is defined as follows:\n\n- \\( T(S) \\) is a rooted tree having exactly \\( n \\) leaves.\n- Every edge of \\( T(S) \\) is labeled with a substring of \\( S^* \\), where \\( S^* \\) is the string formed by adding a placeholder symbol \\( \\$ \\) to the end of \\( S \\).\n- Every internal node of \\( T(S) \\) other than the root has at least two children; i.e., it has degree at least 3.\n- The substring labels for the edges leading from a node to its children must begin with different symbols.\n- By concatenating the substrings along edges, each path from the root to a leaf corresponds to a unique suffix of \\( S^* \\).\n\nSee Figure 1 for an example of a suffix tree.\n\nGiven: A DNA string \\( S \\) (of length at most 20 kbp) with \\( \\$ \\) appended, a positive integer \\( k \\), and a list of edges defining the suffix tree of \\( S \\). Each edge is represented by four components:\n\n1. The label of its parent node in \\( T(S) \\);\n2. The label of its child node in \\( T(S) \\);\n3. The location of the substring \\( t \\) of \\( S^* \\) assigned to the edge; and\n4. The length of \\( t \\).\n\nReturn: The longest substring of \\( S \\) that occurs at least \\( k \\) times in \\( S \\). (If multiple solutions exist, you may return any single solution.)\n\nSample Dataset\nCATACATAC$\n2\nnode1 node2 1 1\nnode1 node7 2 1\nnode1 node14 3 3\nnode1 node17 10 1\nnode2 node3 2 4\nnode2 node6 10 1\nnode3 node4 6 5\nnode3 node5 10 1\nnode7 node8 3 3\nnode7 node11 5 1\nnode8 node9 6 5\nnode8 node10 10 1\nnode11 node12 6 5\nnode11 node13 10 1\nnode14 node15 6 5\nnode14 node16 10 1",
    "In a **weighted tree**, each edge is assigned a (usually positive) number, called its **weight**. The **distance** between two nodes in a weighted tree becomes the sum of the weights along the unique path connecting the nodes.\n\nTo generalize **Newick format** to the case of a weighted tree \\( T \\), during our repeated \"key step,\" if leaves \\( V_1, V_2, \\ldots, V_n \\) are **neighbors** in \\( T \\), and all these leaves are incident to \\( U \\), then we replace \\( U \\) with \\( (V_1 : d_1, V_2 : d_2, \\ldots, V_n : d_n)U \\), where \\( d_i \\) is now the weight on the edge \\( \\{V_i, U\\} \\).\n\nGiven: A collection of \\( n \\) weighted trees (\\( n \\leq 40 \\)) in Newick format, with each tree containing at most 200 nodes; each tree \\( T_k \\) is followed by a pair of nodes \\( X_k \\) and \\( Y_k \\) in \\( T_k \\).\n\nReturn: A collection of \\( n \\) numbers, for which the \\( k \\)-th number represents the distance between \\( X_k \\) and \\( Y_k \\) in \\( T_k \\).\n\nSample Dataset\n\n```\n(dog:42,cat:33);\ncat dog\n\n((dog:4,cat:3):74,robot:98,elephant:58);\ndog elephant\n```",
    "Given an RNA string \\( S \\), we will augment the **bonding graph** of \\( S \\) by adding **basepair edges** connecting all occurrences of 'U' to all occurrences of 'G' in order to represent possible wobble base pairs.\n\nWe say that a matching in the bonding graph for \\( S \\) is **valid** if it is **noncrossing** (to prevent pseudoknots) and has the property that a basepair edge in the matching cannot connect symbols \\( S_j \\) and \\( S_k \\) unless \\( k \\geq j + 4 \\) (to prevent nearby nucleotides from base pairing).\n\nSee Figure 1 for an example of a valid matching if we allow wobble base pairs. In this problem, we will wish to count all possible valid matchings in a given bonding graph; see Figure 2 for all possible valid matchings in a small bonding graph, assuming that we allow wobble base pairing.\n\nGiven: An RNA string \\( S \\) (of length at most 200 bp).\n\nReturn: The total number of **distinct** valid matchings of basepair edges in the bonding graph of \\( S \\). Assume that wobble base pairing is allowed.\n\n\nSample Dataset\nAUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU",
    "To model the Hardy-Weinberg principle, assume that we have a population of \\( N \\) diploid individuals. If an allele is in genetic equilibrium, then because mating is random, we may view the \\( 2N \\) chromosomes as receiving their alleles uniformly. In other words, if there are \\( m \\) dominant alleles, then the probability of a selected chromosome exhibiting the dominant allele is simply \\( p = \\frac{m}{2N} \\).\n\nBecause the first assumption of genetic equilibrium states that the population is so large as to be ignored, we will assume that \\( N \\) is infinite, so that we only need to concern ourselves with the value of \\( p \\).\n\nGiven: An array \\( A \\) for which \\( A[k] \\) represents the proportion of **homozygous recessive** individuals for the \\( k \\)-th Mendelian factor in a diploid population. Assume that the population is in genetic equilibrium for all factors.\n\nReturn: An array \\( B \\) having the same length as \\( A \\) in which \\( B[k] \\) represents the **probability** that a randomly selected individual carries at least one copy of the **recessive allele** for the \\( k \\)-th factor.\n\nSample Dataset\n\n```\n0.1 0.25 0.5\n```",
    "A collection of strings is characterizable if there are at most two possible choices for the symbol at each position of the strings.\n\nGiven: A collection of at most 100 characterizable DNA strings, each of length at most 300 bp.\n\nReturn: A character table for which each nontrivial character encodes the symbol choice at a single position of the strings. (Note: the choice of assigning '1' and '0' to the two states of each SNP in the strings is arbitrary.)\n\nSample Dataset\nATGCTACC\nCGTTTACC\nATTCGACC\nAGTCTCCC\nCGTCTATC",
    "Recall from \"Edit Distance Alignment\" that if \\( S' \\) and \\( t' \\) are the **augmented strings** corresponding to an alignment of strings \\( S \\) and \\( t \\), then the **edit alignment score** of \\( S' \\) and \\( t' \\) was given by the Hamming distance \\( d_H(S', t') \\) (because \\( S' \\) and \\( t' \\) have the same length and already include gap symbols to denote insertions/deletions).\n\nAs a result, we obtain \\( d_E(S, t) = \\min_{S', t'} d_H(S', t') \\), where the minimum is taken over all alignments of \\( S \\) and \\( t \\). Strings \\( S' \\) and \\( t' \\) achieving this minimum correspond to an optimal alignment with respect to edit alignment score.\n\nGiven: Two **protein strings** \\( S \\) and \\( t \\) in FASTA format, each of length at most 1000 aa.\n\nReturn: The total number of optimal alignments of \\( S \\) and \\( t \\) with respect to edit alignment score, modulo \\( 134,217,727 \\) (\\( 2^{27} - 1 \\)).\n\nSample Dataset\n\n```\n>Rosalind_78\nPLEASANTLY\n>Rosalind_33\nMEANLY\n```",
    "A circular string is a string that does not have an initial or terminal element; instead, the string is viewed as a necklace of symbols. We can represent a circular string as a string enclosed in parentheses. For example, consider the circular DNA string (ACGTAC), and note that because the string \"wraps around\" at the end, this circular string can equally be represented by (CGTACA), (GTACAC), (TACACG), (ACACGT), and (CACGTA). The definitions of substrings and superstrings are easy to generalize to the case of circular strings (keeping in mind that substrings are allowed to wrap around).\n\nGiven: A collection of (error-free) DNA k\n-mers (k≤50\n) taken from the same strand of a circular chromosome. In this dataset, all k\n-mers from this strand of the chromosome are present, and their de Bruijn graph consists of exactly one simple cycle.\n\nReturn: A cyclic superstring of minimal length containing the reads (thus corresponding to a candidate cyclic chromosome).\n\nSample Dataset\nATTAC\nTACAG\nGATTA\nACAGA\nCAGAT\nTTACA\nAGATT",
    "The **complete spectrum** of a weighted string \\( S \\) is the multiset \\( S[s] \\) containing the weights of every prefix and suffix of \\( S \\).\n\nGiven: A positive integer \\( n \\) followed by a collection of \\( n \\) protein strings \\( s_1, s_2, \\ldots, s_n \\) and a multiset \\( R \\) of positive numbers (corresponding to the complete spectrum of some unknown protein string).\n\nReturn: The maximum multiplicity of \\( R \\ominus S[s_k] \\) taken over all strings \\( s_k \\), followed by the string \\( s_k \\) for which this maximum multiplicity occurs (you may output any such value if multiple solutions exist).\n\n\nSample Dataset\n4\nGSDMQS\nVWICN\nIASWMQS\nPVSMGAD\n445.17838\n115.02694\n186.07931\n314.13789\n317.1198\n215.09061",
    "A **partial split** of a set \\( S \\) of \\( n \\) taxa models a partial character and is denoted by \\( A \\mid B \\), where \\( A \\) and \\( B \\) are still the two disjoint subsets of taxa divided by the character. Unlike in the case of splits, we do not necessarily require that \\( A \\cup B = S \\); \\( (A \\cup B)^c \\) corresponds to those taxa for which we lack conclusive evidence regarding the character.\n\nWe can assemble a collection of partial characters into a generalized **partial character table** \\( C \\) in which the symbol \\( X \\) is placed in \\( C_{i,j} \\) if we do not have conclusive evidence regarding the \\( j \\)-th taxon with respect to the \\( i \\)-th partial character.\n\nA **quartet** is a partial split \\( A \\mid B \\) in which both \\( A \\) and \\( B \\) contain precisely two elements. For the sake of simplicity, we often will consider quartets instead of partial characters. We say that a quartet \\( A \\mid B \\) is inferred from a partial split \\( C \\mid D \\) if \\( A \\subseteq C \\) and \\( B \\subseteq D \\) (or equivalently \\( A \\subseteq D \\) and \\( B \\subseteq C \\)). For example, \\( \\{1, 3\\} \\mid \\{2, 4\\} \\) and \\( \\{3, 5\\} \\mid \\{2, 4\\} \\) can be inferred from \\( \\{1, 3, 5\\} \\mid \\{2, 4\\} \\).\n\nGiven: A partial character table \\( C \\).\n\nReturn: The collection of all quartets that can be inferred from the splits corresponding to the underlying characters of \\( C \\).\n\nSample Dataset\n\n```\ncat dog elephant ostrich mouse rabbit robot\n01xxx00\nx11xx00\n111x00x\n```",
    "For a weighted alphabet \\( \\mathcal{A} \\) and a collection \\( L \\) of positive real numbers, the **spectrum graph** of \\( L \\) is a digraph constructed in the following way. First, create a node for every real number in \\( L \\). Then, connect a pair of nodes with a directed edge \\( (u, v) \\) if \\( v > u \\) and \\( v - u \\) is equal to the weight of a single symbol in \\( \\mathcal{A} \\). We may then label the edge with this symbol.\n\nIn this problem, we say that a weighted string \\( S = S_1 S_2 \\cdots S_n \\) matches \\( L \\) if there is some increasing sequence of positive real numbers \\( (w_1, w_2, \\ldots, w_{n+1}) \\) in \\( L \\) such that \\( w(S_1) = w_2 - w_1 \\), \\( w(S_2) = w_3 - w_2 \\), ..., and \\( w(S_n) = w_{n+1} - w_n \\).\n\nGiven: A list \\( L \\) (of length at most 100) containing positive real numbers.\n\nReturn: The longest protein string that matches the spectrum graph of \\( L \\) (if multiple solutions exist, you may output any one of them). Consult the monoisotopic mass table.\n\nSample Dataset\n\n```\n3524.8542\n3623.5245\n3710.9335\n3841.974\n3929.00603\n3970.0326\n4026.05879\n4057.0646\n4083.08025\n```",
    "Given a string s\n having length n\n, recall that its suffix tree T(s)\n is defined by the following properties:\n\nT(s)\n is a rooted tree having exactly n\n leaves.\nEvery edge of T(s)\n is labeled with a substring of s∗\n, where s∗\n is the string formed by adding a placeholder symbol $ to the end of s\n.\nEvery internal node of T(s)\n other than the root has at least two children; i.e., it has degree at least 3.\nThe substring labels for the edges leading down from a node to its children must begin with different symbols.\nBy concatenating the substrings along edges, each path from the root to a leaf corresponds to a unique suffix of s∗\n\nGiven: A DNA string s\n of length at most 1kbp.\n\nReturn: The substrings of s∗\n encoding the edges of the suffix tree for s\n. You may list these substrings in any order.\n\nSample Dataset\nATAAATG$\n",
    "Because a tree having \\( n \\) nodes has \\( n - 1 \\) edges (see \"Completing a Tree\"), removing a single edge from a tree will produce two smaller, disjoint trees. Recall from \"Creating a Character Table\" that for this reason, each edge of an unrooted binary tree corresponds to a split \\( S \\mid S^c \\), where \\( S \\) is a subset of the taxa.\n\nA **consistent character table** is one whose characters' splits do not conflict with the edge splits of some unrooted binary tree \\( T \\) on the \\( n \\) taxa. More precisely, \\( S_1 \\mid S_1^c \\) conflicts with \\( S_2 \\mid S_2^c \\) if all four intersections \\( S_1 \\cap S_2 \\), \\( S_1 \\cap S_2^c \\), \\( S_1^c \\cap S_2 \\), and \\( S_1^c \\cap S_2^c \\) are nonempty. As a simple example, consider the conflicting splits \\( \\{a, b\\} \\mid \\{c, d\\} \\) and \\( \\{a, c\\} \\mid \\{b, d\\} \\).\n\nMore generally, given a consistent character table \\( C \\), an unrooted binary tree \\( T \\) \"models\" \\( C \\) if the edge splits of \\( T \\) agree with the splits induced from the characters of \\( C \\).\n\nGiven: A list of \\( n \\) species (\\( n \\leq 80 \\)) and an \\( n \\)-column character table \\( C \\) in which the \\( j \\)-th column denotes the \\( j \\)-th species.\n\nReturn: An unrooted binary tree in Newick format that models \\( C \\).\n\nSample Dataset\n\n```\ncat dog elephant mouse rabbit rat\n011101\n001101\n001100\n```",
    "A quartet AB | CD is consistent with a binary tree T if the quartet can be inferred from one of the splits of T (see “Quartets” for a description of inferring quartets from splits).\n\nLet q(T) denote the total number of quartets that are consistent with T.\n\nGiven: A positive integer n (4 ≤ n ≤ 5000), followed by an unrooted binary tree T in Newick format on n taxa.\n\nReturn: The value of q(T) modulo 1,000,000.\n\nSample Dataset\n\n6  \n(lobster,(cat,dog),(caterpillar,(elephant,mouse)));",
    "Given: A collection of species names representing n\n taxa.\n\nReturn: A list containing all unrooted binary trees whose leaves are these n\n taxa. Trees should be given in Newick format, with one tree on each line; the order of the trees is unimportant.\n\nSample Dataset\ndog cat mouse elephant",
    "A directed cycle is simply a cycle in a directed graph in which the head of one edge is equal to the tail of the next (so that every edge in the cycle is traversed in the same direction).\n\nFor a set of DNA strings S and a positive integer k, let Sk denote the collection of all possible k-mers of the strings in S.\n\nGiven: A collection S of (error-free) reads of equal length (not exceeding 50 bp). In this dataset, for some positive integer k, the de Bruijn graph Bk on Sk+1 ∪ Sk+1^c consists of exactly two directed cycles.\n\nReturn: A cyclic superstring of minimal length containing every read or its reverse complement.\n\nSample Dataset\n\nAATCT  \nTGTAA  \nGATTA  \nACAGA",
    "In a constant gap penalty, every gap receives some predetermined constant penalty, regardless of its length. Thus, the insertion or deletion of 1000 contiguous symbols is penalized equally to that of a single symbol.\n\nGiven: Two protein strings s\n and t\n in FASTA format (each of length at most 1000 aa).\n\nReturn: The maximum alignment score between s\n and t\n. Use:\n\nThe BLOSUM62 scoring matrix.\nConstant gap penalty equal to 5.\nSample Dataset\n>Rosalind_79\nPLEASANTLY\n>Rosalind_41\nMEANLY",
    "Given a length n string S formed over an alphabet A of size α, let the \"substring count\" Sub(s) denote the total number of distinct substrings of S. Furthermore, let the \"maximum substring count\" m(α, n) denote the maximum number of distinct substrings that could appear in a string of length n formed over A.\n\nThe linguistic complexity of S (written lc(s)) is equal to \\(\\frac{\\text{sub}(s)}{\\text{m}(\\alpha, n)}\\); in other words, lc(s) represents the percentage of observed substrings of S to the total number that are theoretically possible. Note that \\(0 < \\text{lc}(s) < 1\\), with smaller values of |lc(s)| indicating that S is more repetitive.\n\nAs an example, consider the DNA string (α = 4) s = ATTTGGATT. In the following table, we demonstrate that \\(\\text{lc}(s) = \\frac{35}{40} = 0.875\\) by considering the number of observed and possible length k substrings of S, which are denoted by subk(s) and m(α, k, n), respectively. (Observe that m(α, n) = ∑_{k=1}^{n} m(α, k, n) = 40 and sub(s) = ∑_{k=1}^{n} sub_k(s) = 35.)\n\n| k | sub_k(s) | m(α, k, n) |\n|---|----------|-------------|\n| 1 | 3        | 4           |\n| 2 | 5        | 8           |\n| 3 | 6        | 7           |\n| 4 | 6        | 6           |\n| 5 | 5        | 5           |\n| 6 | 4        | 4           |\n| 7 | 3        | 3           |\n| 8 | 2        | 2           |\n| 9 | 1        | 1           |\n| Total | 35 | 40 |\n\nGiven: A DNA string S of length at most 100 kbp.\n\nReturn: The linguistic complexity lc(s).\n\nSample Dataset\n\nATTTGGATT",
    "A local alignment of two strings s\n and t\n is an alignment of substrings r\n and u\n of s\n and t\n, respectively. Let opt(r,u)\n denote the score of an optimal alignment of r\n and u\n with respect to some predetermined alignment score.\n\nGiven: Two protein strings s\n and t\n in FASTA format (each having length at most 1000 aa).\n\nReturn: A maximum alignment score along with substrings r\n and u\n of s\n and t\n, respectively, which produce this maximum alignment score (multiple solutions may exist, in which case you may output any one). Use:\n\nThe PAM250 scoring matrix.\nLinear gap penalty equal to 5.\nSample Dataset\n>Rosalind_80\nMEANLYPRTEINSTRING\n>Rosalind_21\nPLEASANTLYEINSTEIN",
    "A rooted binary tree can be used to model the pedigree of an individual. In this case, rather than time progressing from the root to the leaves, the tree is viewed upside down with time progressing from an individual's ancestors (at the leaves) to the individual (at the root).\n\nGiven: A rooted binary tree T\n in Newick format encoding an individual's pedigree for a Mendelian factor whose alleles are A (dominant) and a (recessive).\n\nReturn: Three numbers between 0 and 1, corresponding to the respective probabilities that the individual at the root of T\n will exhibit the \"AA\", \"Aa\" and \"aa\" genotypes.\n\nSample Dataset\n((((Aa,aa),(Aa,Aa)),((aa,aa),(aa,AA))),Aa);",
    "For the computation of an alignment score generalizing the edit alignment score, let m\n denote the score assigned to matched symbols, d\n denote the score assigned to mismatched non-gap symbols, and g\n denote the score assigned a symbol matched to a gap symbol '-' (i.e., g\n is a linear gap penalty).\n\nGiven: Two DNA strings s\n and t\n in FASTA format (each of length at most 5000 bp).\n\nReturn: The maximum number of gap symbols that can appear in any maximum score alignment of s\n and t\n with score parameters satisfying m>0\n, d<0\n, and g<0\n.\n\nSample Dataset\n>Rosalind_92\nAACGTA\n>Rosalind_47\nACACCTA",
    "A maximal repeat of a string s\n is a repeated substring t\n of s\n having two occurrences t1\n and t2\n such that t1\n and t2\n cannot be extended by one symbol in either direction in s\n and still agree.\n\nFor example, \"AG\" is a maximal repeat in \"TAGTTAGCGAGA\" because even though the first two occurrences of \"AG\" can be extended left into \"TAG\", the first and third occurrences differ on both sides of the repeat; thus, we conclude that \"AG\" is a maximal repeat. Note that \"TAG\" is also a maximal repeat of \"TAGTTAGCGAGA\", since its only two occurrences do not still match if we extend them in either direction.\n\nGiven: A DNA string s\n of length at most 1 kbp.\n\nReturn: A list containing all maximal repeats of s\n having length at least 20.\n\nSample Dataset\nTAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTATTATATAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT",
    "A multiple alignment of a collection of three or more strings is formed by adding gap symbols to the strings to produce a collection of augmented strings all having the same length.\n\nA multiple alignment score is obtained by taking the sum of an alignment score over all possible pairs of augmented strings. The only difference in scoring the alignment of two strings is that two gap symbols may be aligned for a given pair (requiring us to specify a score for matched gap symbols).\n\nGiven: A collection of four DNA strings of length at most 10 bp in FASTA format.\n\nReturn: A multiple alignment of the strings having maximum score, where we score matched symbols 0 (including matched gap symbols) and all mismatched symbols -1 (thus incorporating a linear gap penalty of 1).\n\nSample Dataset\n>Rosalind_7\nATATCCG\n>Rosalind_35\nTCCG\n>Rosalind_23\nATGTACTG\n>Rosalind_44\nATGTCTG",
    "For a rooted tree T whose internal nodes are labeled with genetic strings, our goal is to identify reversing substitutions in T. Assuming that all the strings of T have the same length, a reversing substitution is defined formally as two parent-child string pairs (s, t) and (v, w) along with a position index i, where:\n\n- there is a path in T from s down to w;\n- s[i] = w[i] ≠ v[i] = t[i]; and\n- if u is on the path connecting t to v, then t[i] = u[i].\n\nIn other words, the third condition demands that a reversing substitution must be contiguous: no other substitutions can appear between the initial and reversing substitution.\n\nGiven: A rooted binary tree T with labeled nodes in Newick format, followed by a collection of at most 100 DNA strings in FASTA format whose labels correspond to the labels of T. We will assume that the DNA strings have the same length, which does not exceed 400 bp).\n\nReturn: A list of all reversing substitutions in T (in any order), with each substitution encoded by the following three items:\n- the name of the species in which the symbol is first changed, followed by the name of the species in which it changes back to its original state;\n- the position in the string at which the reversing substitution occurs; and\n- the reversing substitution in the form original_symbol->substituted_symbol->reverted_symbol.\n\nSample Dataset\n(((ostrich,cat)rat,mouse)dog,elephant)robot;\n>robot\nAATTG\n>dog\nGGGCA\n>mouse\nAAGAC\n>rat\nGTTGT\n>cat\nGAGGC\n>ostrich\nGTGTC\n>elephant\nAATTC",
    "Say that we have two strings S and t of respective lengths m and n and an alignment score. Let's define a matrix M corresponding to S and t by setting M_{j,k} equal to the maximum score of any alignment that aligns S[j] with t[k]. So each entry in M can be equal to at most the maximum score of any alignment of S and t.\n\nGiven: Two DNA strings S and t in FASTA format, each having length at most 1000 bp.\n\nReturn: The maximum alignment score of a global alignment of S and t, followed by the sum of all elements of the matrix M corresponding to S and t that was defined above. Apply the mismatch score introduced in “Finding a Motif with Modifications”.\n\nSample Dataset\n\n>Rosalind_35  \nATAGATA  \n\n>Rosalind_5  \nACAGGTA",
    "Given: Two protein strings s\n and t\n in FASTA format (each having length at most 10,000 aa).\n\nReturn: The maximum local alignment score of s\n and t\n, followed by substrings r\n and u\n of s\n and t\n, respectively, that correspond to the optimal local alignment of s\n and t\n. Use:\n\nThe BLOSUM62 scoring matrix.\nGap opening penalty equal to 11.\nGap extension penalty equal to 1.\nIf multiple solutions exist, then you may output any one.\n\nSample Dataset\n>Rosalind_8\nPLEASANTLY\n>Rosalind_18\nMEANLY",
    "Given: A positive integer k (k ≤ 50), a DNA string S of length at most 5 kbp representing a motif, and a DNA string t of length at most 50 kbp representing a genome.\n\nReturn: All substrings t' of t such that the edit distance d_E(S, t') is less than or equal to k. Each substring should be encoded by a pair containing its location in t followed by its length.\n\nSample Dataset\n\n2  \nACGTAG  \nACGGATCGGCACTCGT",
    "A semiglobal alignment of strings s\n and t\n is an alignment in which any gaps appearing as prefixes or suffixes of s\n and t\n do not contribute to the alignment score.\n\nSemiglobal alignment has sometimes also been called \"overlap alignment\". Rosalind defines overlap alignment differently (see “Overlap Alignment”).\n\nGiven: Two DNA strings s\n and t\n in FASTA format, each having length at most 10 kbp.\n\nReturn: The maximum semiglobal alignment score of s\n and t\n, followed by an alignment of s\n and t\n achieving this maximum score. Use an alignment score in which matching symbols count +1, substitutions count -1, and there is a linear gap penalty of 1. If multiple optimal alignments exist, then you may return any one.\n\nSample Dataset\n>Rosalind_79\nCAGCACTTGGATTCTCGG\n>Rosalind_98\nCAGCGTGG",
    "Given a string s\n and a motif t\n, an alignment of a substring of s\n against all of t\n is called a fitting alignment. Our aim is to find a substring s′\n of s\n that maximizes an alignment score with respect to t\n.\n\nNote that more than one such substring of s\n may exist, depending on the particular strings and alignment score used. One candidate for scoring function is the one derived from edit distance; In this problem, we will consider a slightly different alignment score, in which all matched symbols count as +1 and all mismatched symbols (including insertions and deletions) receive a cost of -1. Let's call this scoring function the mismatch score. \nGiven: Two DNA strings s\n and t\n, where s\n has length at most 10 kbp and t\n represents a motif of length at most 1 kbp.\n\nReturn: An optimal fitting alignment score with respect to the mismatch score defined above, followed by an optimal fitting alignment of a substring of s\n against t\n. If multiple such alignments exist, then you may output any one.\n\nSample Dataset\n>Rosalind_54\nGCAAACCATAAGCCCTACGTGCCGCCTGTTTAAACTCGCGAACTGAATCTTCTGCTTCACGGTGAAAGTACCACAATGGTATCACACCCCAAGGAAAC\n>Rosalind_46\nGCCGTCAGGCTGGTGTCCG",
    "In \"Counting Quartets\", we found an expression for q(T), the number of quartets that can be inferred from an unrooted binary tree containing n taxa.\n\nIf T₁ and T₂ are both unrooted binary trees on the same n taxa, then we now let q(T₁, T₂) denote the number of inferred quartets that are common to both trees. The quartet distance between T₁ and T₂, d_q(T₁, T₂), is the number of quartets that are only inferred from one of the trees. More precisely, d_q(T₁, T₂) = q(T₁) + q(T₂) − 2q(T₁, T₂).\n\nGiven: A list containing n taxa (n ≤ 2000) and two unrooted binary trees T₁ and T₂ on the given taxa. Both T₁ and T₂ are given in Newick format.\n\nReturn: The quartet distance d_q(T₁, T₂).\n\nSample Dataset\n\nA B C D E  \n(A,C,((B,D),E));  \n(C,((B,D),(A,E)));",
    "An **overlap alignment** between two strings S and t is a local alignment of a suffix of S with a prefix of t. An optimal overlap alignment will therefore maximize an alignment score over all such substrings of S and t.\n\nThe term \"overlap alignment\" has also been used to describe what Rosalind defines as a semiglobal alignment. See “Semiglobal Alignment” for details.\n\nGiven: Two DNA strings S and t in FASTA format, each having length at most 10 kbp.\n\nReturn: The score of an optimal overlap alignment of S and t, followed by an alignment of a suffix S′ of S and a prefix t′ of t achieving this optimal score. Use an alignment score in which matching symbols count +1, substitutions count -2, and there is a linear gap penalty of 2. If multiple optimal alignments exist, then you may return any one.\n\nSample Dataset\n\n>Rosalind_54  \nCTAAGGGATTCGCGTAATTAGACAG  \n\n>Rosalind_45  \nATAGACCATATGTCAGTGACTGTGTGTA",
    "\nRecall that a **directed cycle** is a cycle in a directed graph in which the head of one edge is equal to the tail of the following edge.\n\nIn a de Bruijn graph of k-mers, a circular string S is constructed from a directed cycle \\( S_1 \\to S_2 \\to \\ldots \\to S_l \\to S_1 \\) by given \\( S_1 + S_2[k] + \\ldots + S_{l-k}[k] + S_{l-k+1}[k] \\). That is, because the final \\( k-1 \\) symbols of \\( S_1 \\) overlap with the first \\( k-1 \\) symbols of \\( S_2 \\), we simply tack on the \\( k \\)-th symbol of \\( S_2 \\) to \\( S \\), then iterate the process.\n\nFor example, the circular string assembled from the cycle \"AC\" → \"CT\" → \"TA\" → \"AC\" is simply (ACT). Note that this string only has length three because the 2-mers \"wrap around\" in the string.\n\nIf every k-mer in a collection of reads occurs as an edge in a de Bruijn graph cycle the same number of times as it appears in the reads, then we say that the cycle is \"complete.\"\n\nGiven: A list \\( S_{k+1} \\) of error-free DNA \\((k+1)\\)-mers (\\( k \\leq 5 \\)) taken from the same strand of a circular chromosome (of length ≤ 50).\n\nReturn: All circular strings assembled by complete cycles in the de Bruijn graph \\( B_k \\) of \\( S_{k+1} \\). The strings may be given in any order, but each one should begin with the first \\((k+1)\\)-mer provided in the input.\n\nSample Dataset\nCAG\nAGT\nGTT\nTTT\nTTG\nTGG\nGGC\nGCG\nCGT\nGTT\nTTC\nTCA\nCAA\nAAT\nATT\nTTC\nTCA",
    "An **affine gap penalty** is written as \\( a + b \\cdot (L - 1) \\), where \\( L \\) is the length of the gap, \\( a \\) is a positive constant called the **gap opening penalty**, and \\( b \\) is a positive constant called the **gap extension penalty**.\n\nWe can view the gap opening penalty as charging for the first gap symbol, and the gap extension penalty as charging for each subsequent symbol added to the gap.\n\nFor example, if \\( a = 11 \\) and \\( b = 1 \\), then a gap of length 1 would be penalized by 11 (for an average cost of 11 per gap symbol), whereas a gap of length 100 would have a score of 110 (for an average cost of 1.10 per gap symbol).\n\nConsider the strings \"PRTEINS\" and \"PRTWPSEIN\". If we use the BLOSUM62 scoring matrix and an affine gap penalty with \\( a = 11 \\) and \\( b = 1 \\), then we obtain the following optimal alignment:\n\n```\nPRT---EINS\n|||    |||\nPRTWPSEIN-\n```\n\nMatched symbols contribute a total of 32 to the calculation of the alignment's score, and the gaps cost 13 and 11 respectively, yielding a total score of 8.\n\nGiven: Two protein strings S and t in FASTA format (each of length at most 100 aa).\n\nReturn: The maximum alignment score between S and t, followed by two augmented strings \\( S' \\) and \\( t' \\) representing an optimal alignment of S and t. Use:\n- The BLOSUM62 scoring matrix.\n- Gap opening penalty equal to 11.\n- Gap extension penalty equal to 1.\n\nSample Dataset\n>Rosalind_49\nPRTEINS\n>Rosalind_47\nPRTWPSEIN",
    "Given: Two positive integers N\n and m\n, followed by an array A\n containing k\n integers between 0 and 2N\n. A[j]\n represents the number of recessive alleles for the j\n-th factor in a population of N\n diploid individuals.\n\nReturn: An m×k\n matrix B\n for which Bi,j\n represents the common logarithm of the probability that after i\n generations, no copies of the recessive allele for the j\n-th factor will remain in the population. Apply the Wright-Fisher model.\n\nSample Dataset\n4 3\n0 1 2",
    "In “The Wright-Fisher Model of Genetic Drift”, we generalized the concept of a binomial random variable Bin(n,p)\n as a \"weighted coin flip.\" It is only natural to calculate the expected value of such a random variable.\n\nFor example, in the case of unweighted coin flips (i.e., p=1/2\n), our intuition would indicate that E(Bin(n,1/2))\n is n/2\n; what should be the expected value of a binomial random variable?\n\nGiven: A positive integer n\n (n≤1000000\n) followed by an array P\n of length m\n (m≤20\n) containing numbers between 0\n and 1\n. Each element of P\n can be seen as representing a probability corresponding to an allele frequency.\n\nReturn: An array B\n of length m\n for which B[k]\n is the expected value of Bin(n,P[k])\n; in terms of Wright-Fisher, it represents the expected allele frequency of the next generation.\n\nSample Dataset\n17\n0.1 0.2 0.3",
    "A submatrix of a matrix M\n is a matrix formed by selecting rows and columns from M\n and taking only those entries found at the intersections of the selected rows and columns. We may also think of a submatrix as formed by deleting the remaining rows and columns from M\n.\n\nGiven: An inconsistent character table C\n on at most 100 taxa.\n\nReturn: A submatrix of C′\n representing a consistent character table on the same taxa and formed by deleting a single row of C\n. (If multiple solutions exist, you may return any one.)\n\nSample Dataset\n100001\n000110\n111000\n100111",
    "Given a collection of DNA strings representing contigs, we use the N statistic NXX (where XX ranges from 01 to 99) to represent the maximum positive integer L\n such that the total number of nucleotides of all contigs having length ≥L\n is at least XX% of the sum of contig lengths. The most commonly used such statistic is N50, although N75 is also worth mentioning.\n\nGiven: A collection of at most 1000 DNA strings (whose combined length does not exceed 50 kbp).\n\nReturn: N50 and N75 for this collection of strings.\n\nSample Dataset\nGATTACA\nTACTACTAC\nATTGAT\nGAAGA",
    "Say that we have \\( n \\) taxa represented by strings \\( S_1, S_2, \\ldots, S_n \\) with a multiple alignment inducing corresponding augmented strings \\( \\overline{S}_1, \\overline{S}_2, \\ldots, \\overline{S}_n \\).\n\nRecall that the number of single-symbol substitutions required to transform one string into another is the Hamming distance between the strings (see “Counting Point Mutations”). Say that we have a rooted binary tree \\( T \\) containing \\( \\overline{S}_1, \\overline{S}_2, \\ldots, \\overline{S}_n \\) at its leaves and additional strings \\( \\overline{S}_{n+1}, \\overline{S}_{n+2}, \\ldots, \\overline{S}_{2n-1} \\) at its internal nodes, including the root (the number of internal nodes is \\( n - 1 \\) by extension of “Counting Phylogenetic Ancestors”). Define \\( d_H(T) \\) as the sum of \\( d_H(\\overline{S}_i, \\overline{S}_j) \\) over all edges \\( \\{\\overline{S}_i, \\overline{S}_j\\} \\) in \\( T \\):\n\n\\[\nd_H(T) = \\sum_{\\{\\overline{S}_i, \\overline{S}_j\\} \\in E(T)} d_H(\\overline{S}_i, \\overline{S}_j)\n\\]\n\nThus, our aim is to minimize \\( d_H(T) \\).\n\nGiven: A rooted binary tree \\( T \\) on \\( n \\) (\\( n \\leq 500 \\)) species, given in Newick format, followed by a multiple alignment of \\( m \\) (\\( m \\leq n \\)) augmented DNA strings having the same length (at most 300 bp) corresponding to the species and given in FASTA format.\n\nReturn: The minimum possible value of \\( d_H(T) \\), followed by a collection of DNA strings to be assigned to the internal nodes of \\( T \\) that will minimize \\( d_H(T) \\) (multiple solutions will exist, but you need only output one).\n\n\nSample Dataset\n(((ostrich,cat)rat,(duck,fly)mouse)dog,(elephant,pikachu)hamster)robot;\n>ostrich\nAC\n>cat\nCA\n>duck\nT-\n>fly\nGC\n>elephant\n-T\n>pikachu\nAA",
    "Consider flipping a weighted coin that gives \"heads\" with some fixed probability \\( p \\) (i.e., \\( p \\) is not necessarily equal to \\( \\frac{1}{2} \\)).\n\nWe generalize the notion of **binomial random variable** from \"Independent Segregation of Chromosomes\" to quantify the sum of the weighted coin flips. Such a random variable \\( X \\) takes a value of \\( k \\) if a sequence of \\( n \\) independent \"weighted coin flips\" yields \\( k \\) \"heads\" and \\( n - k \\) \"tails.\" We write that \\( X \\in \\text{Bin}(n, p) \\).\n\nTo quantify the Wright-Fisher Model of genetic drift, consider a population of \\( N \\) diploid individuals, whose \\( 2N \\) chromosomes possess \\( m \\) copies of the dominant allele. As in \"Counting Disease Carriers,\" set \\( p = \\frac{m}{2N} \\). Next, recall that the next generation must contain exactly \\( N \\) individuals. These individuals' \\( 2N \\) alleles are selected independently: a dominant allele is chosen with probability \\( p \\), and a recessive allele is chosen with probability \\( 1 - p \\).\n\nGiven: Positive integers \\( N \\) (\\( N \\leq 7 \\)), \\( m \\) (\\( m \\leq 2N \\)), \\( g \\) (\\( g \\leq 6 \\)), and \\( k \\) (\\( k \\leq 2N \\)).\n\nReturn: The probability that in a population of \\( N \\) diploid individuals initially possessing \\( m \\) copies of a dominant allele, we will observe after \\( g \\) generations at least \\( k \\) copies of a recessive allele. Assume the Wright-Fisher model.\n\nSample Dataset\n\n4 6 2 1",
    "Define the **split distance** between two unrooted binary trees as the number of nontrivial splits contained in one tree but not the other.\n\nFormally, if \\( s(T_1, T_2) \\) denotes the number of nontrivial splits shared by unrooted binary trees \\( T_1 \\) and \\( T_2 \\), then their split distance is:\n\n\\[\nd_{\\text{split}}(T_1, T_2) = 2(n - 3) - 2s(T_1, T_2)\n\\]\n\nGiven: A collection of at most 3,000 species taxa and two unrooted binary trees \\( T_1 \\) and \\( T_2 \\) on these taxa in Newick format.\n\nReturn: The split distance \\( d_{\\text{split}}(T_1, T_2) \\).\n\nSample Dataset\ndog rat elephant mouse cat rabbit\n(rat,(dog,cat),(rabbit,(elephant,mouse)));\n(rat,(cat,dog),(elephant,(mouse,rabbit)));",
    "As in the case of unrooted trees, say that we have a fixed collection of n\n taxa labeling the leaves of a rooted binary tree T\n. You may like to verify that (by extension of “Counting Phylogenetic Ancestors”) such a tree will contain n−1\n internal nodes and 2n−2\n total edges. Any edge will still encode a split of taxa; however, the two splits corresponding to the edges incident to the root of T\n will be equal. We still consider two trees to be equivalent if they have the same splits (which requires that they must also share the same duplicated split to be equal).\n\nLet B(n)\n represent the total number of distinct rooted binary trees on n\n labeled taxa.\n\nGiven: A positive integer n\n (n≤1000\n).\n\nReturn: The value of B(n)\n modulo 1,000,000.\n\nSample Dataset\n4"
  ],
  "final_answer": [
    "20 12 17 21",
    "GAUGGAACUUGACUACGUAAAUU",
    "ACCGGGTTTT",
    "19",
    "60.919540",
    "7",
    "0.78333",
    "MAMAPRTEINSTRING",
    "1.21428571429",
    "TTCAT->TTGAT\nGAGGA->GATGA\nTTTCC->TTTCA",
    "2",
    "4 1 4 3 0 1 1 5 1 3 1 2 2 1 2 0 1 1 3 1 2 1 3 1 1 1 1 2 2 5 1 3 0 2 2 1 1 1 1 3 1 0 0 1 5 5 1 5 0 2 0 2 1 2 1 1 1 2 0 1 0 0 1 1 3 2 1 0 3 2 3 0 0 2 0 8 0 0 1 0 2 1 3 0 0 0 1 4 3 2 1 1 3 1 2 1 3 1 2 1 2 1 1 1 2 3 2 1 1 0 1 1 3 2 1 2 6 2 1 1 1 2 3 3 3 2 3 0 3 2 1 1 0 0 1 4 3 0 1 5 0 2 0 1 2 1 3 0 1 2 2 1 1 0 3 0 0 4 5 0 3 0 2 1 1 3 0 3 2 2 1 1 0 2 1 0 2 2 1 2 0 2 2 5 2 2 1 1 2 1 2 2 2 2 1 1 3 4 0 2 1 1 0 1 2 2 1 1 1 5 2 0 3 2 1 1 2 2 3 0 3 0 1 3 1 2 3 0 2 1 2 2 1 2 3 0 1 2 3 1 1 3 1 0 1 1 3 0 2 1 2 2 0 2 1 1",
    "0 0 0 1 2 0 0 0 0 0 0 1 2 1 2 3 4 5 3 0 0",
    "AACTGG",
    "['D', 'DD', 'DDD', 'DDN', 'DDA', 'DN', 'DND', 'DNN', 'DNA', 'DA', 'DAD', 'DAN', 'DAA', 'N', 'ND', 'NDD', 'NDN', 'NDA', 'NN', 'NND', 'NNN', 'NNA', 'NA', 'NAD', 'NAN', 'NAA', 'A', 'AD', 'ADD', 'ADN', 'ADA', 'AN', 'AND', 'ANN', 'ANA', 'AA', 'AAD', 'AAN', 'AAA']",
    "6",
    "0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000",
    "0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000",
    "0.689",
    "8",
    "5",
    "0.422 0.563 0.422",
    "7",
    "1 2",
    "ATGCATGAT",
    "2\n4 9\n2 5",
    "WMQS",
    "1 2 A\n2 3 T\n3 4 A\n4 5 G\n5 6 A\n3 7 C\n1 8 G\n8 9 A\n9 10 T",
    "3\n85.03163",
    "00110\n00111",
    "[('ATC', 'TCA'), ('ATG', 'TGA'), ('ATG', 'TGC'), ('CAT', 'ATC'), ('CAT', 'ATG'), ('GAT', 'ATG'), ('GCA', 'CAT'), ('TCA', 'CAT'), ('TGA', 'GAT')]",
    "4\nPRETTY--\nPR-TTEIN",
    "KEKEP",
    "[0.0, -0.00042432292765179444, -0.0046905112795315234, -0.024424599331418283, -0.08190410438309813, -0.20547927791864962, -0.423712651968057, -0.7647872888256622, -1.2621119296336116, -1.968907271481587, -3.010299956639812]",
    "0 0 1\n0 1 0\n1 0 0",
    "CATAC",
    "75 136",
    "284850219977421",
    "0.532 0.75 0.914",
    "10110\n10100\n",
    "4",
    "GATTACA",
    "3\nIASWMQS",
    "{elephant, dog} {rabbit, robot}\n{cat, dog} {mouse, rabbit}\n{mouse, rabbit} {cat, elephant}\n{dog, elephant} {mouse, rabbit}",
    "WMSPG",
    "AAATG$\nG$\nT\nATG$\nTG$\nA\nA\nAAATG$\nG$\nT\nG$\n$",
    "(dog,(cat,rabbit),(rat,(elephant,mouse)));",
    "15",
    "(((mouse,cat),elephant))dog;\n(((elephant,mouse),cat))dog;\n(((elephant,cat),mouse))dog;",
    "GATTACA",
    "13",
    "0.875",
    "23\nLYPRTEINSTRIN\nLYEINSTEIN\n",
    "0.156 0.5 0.344\n",
    "3",
    "TAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT\nATGGGTCCAGAGTTTTGTAATTT",
    "-18\nATAT-CCG\n-T---CCG\nATGTACTG\nATGT-CTG",
    "dog mouse 1 A->G->A\ndog mouse 2 A->G->A\nrat ostrich 3 G->T->G\nrat cat 3 G->T->G\ndog rat 3 T->G->T",
    "3\n-139",
    "12\nLEAS\nMEAN",
    "1 4\n1 5\n1 6",
    "4\nCAGCA-CTTGGATTCTCGG\n---CAGCGTGG--------",
    "5\nACCATAAGCCCTACGTG-CCG\nGCCGTCAGGC-TG-GTGTCCG\n",
    "4",
    "1\nATTAGAC-AG\nAT-AGACCAT",
    "CAGTTCAATTTGGCGTT\nCAGTTCAATTGGCGTTT\nCAGTTTCAATTGGCGTT\nCAGTTTGGCGTTCAATT\nCAGTTGGCGTTCAATTT\nCAGTTGGCGTTTCAATT\n",
    "8\nPRT---EINS\nPRTWPSEIN-",
    "0.0 -0.463935575821 -0.999509892866\n0.0 -0.301424998891 -0.641668367342\n0.0 -0.229066698008 -0.485798552456",
    "1.7 3.4 5.1",
    "000110\n100001\n100111",
    "(7, 6)",
    "8\n>rat\nAC\n>mouse\nTC\n>dog\nAC\n>hamster\nAT\n>robot\nAC\n",
    "0.772",
    "2",
    "15"
  ],
  "rationale": [
    "from Bio.Seq import Seq\n\ns = \"AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC\"\nsequence = Seq(s)\n\na_count = sequence.count('A')\nc_count = sequence.count('C')\ng_count = sequence.count('G')\nt_count = sequence.count('T')\n\nresult = f\"{a_count} {c_count} {g_count} {t_count}\"\nprint(result)",
    "from Bio.Seq import Seq\n\nt = \"GATGGAACTTGACTACGTAAATT\"\ndna_seq = Seq(t)\n\nrna_seq = dna_seq.transcribe()\n\nresult = str(rna_seq)\nprint(result)",
    "from Bio.Seq import Seq\n\ns = \"AAAACCCGGT\"\ndna_seq = Seq(s)\n\nreverse_complement_seq = dna_seq.reverse_complement()\n\nresult = str(reverse_complement_seq)\nprint(result)",
    "n = 5\nk = 3\n\ndef fib_rabbit(n, k):\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return fib_rabbit(n-1, k) + k * fib_rabbit(n-2, k)\n\nresult = fib_rabbit(n, k)\nprint(result)",
    "from Bio import SeqIO\n\ndef gc_content(seq):\n    return (seq.count('G') + seq.count('C')) / len(seq) * 100\n\nmax_gc_content = 0\nmax_gc_id = \"\"\n\nfor record in SeqIO.parse(\"sample.fasta\", \"fasta\"):\n    content = gc_content(str(record.seq))\n    if content > max_gc_content:\n        max_gc_content = content\n        max_gc_id = record.id\n\nresult = (max_gc_id, round(max_gc_content, 6))\nprint(result)",
    "s = \"GAGCCTACTAACGGGAT\"\nt = \"CATCGTAATGACGGCCT\"\n\nhamming_distance = sum(sc != tc for sc, tc in zip(s, t))\n\nresult = hamming_distance\nprint(result)",
    "k, m, n = 2, 2, 2\n\ntotal = k + m + n\n\n# Probabilities for each pair producing a dominant phenotype\nprob_dominant = (k/total) * ((k-1)/(total-1)) + (k/total) * (m/(total-1)) + (k/total) * (n/(total-1))\nprob_dominant += (m/total) * (k/(total-1)) + (m/total) * ((m-1)/(total-1)) * 0.75 + (m/total) * (n/(total-1)) * 0.5\nprob_dominant += (n/total) * (k/(total-1)) + (n/total) * (m/(total-1)) * 0.5\n\nresult = prob_dominant\nprint(result)",
    "from Bio.Seq import Seq\n\nrna_string = \"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\"\nrna_seq = Seq(rna_string)\n\nprotein_string = str(rna_seq.translate(to_stop=True))\n\nresult = protein_string\nprint(result)",
    "from Bio import SeqIO\n\ndef transition_transversion_ratio(s1, s2):\n    transitions = 0\n    transversions = 0\n    purines = {'A', 'G'}\n    pyrimidines = {'C', 'T'}\n\n    for base1, base2 in zip(s1, s2):\n        if base1 != base2:\n            if base1 in purines and base2 in purines or base1 in pyrimidines and base2 in pyrimidines:\n                transitions += 1\n            else:\n                transversions += 1\n\n    return transitions / transversions if transversions > 0 else float('inf')\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns1 = str(records[0].seq)\ns2 = str(records[1].seq)\n\nresult = transition_transversion_ratio(s1, s2)\nprint(result)",
    "from Bio import SeqIO\nfrom Bio.Seq import Seq\nfrom collections import Counter, defaultdict\n\ndef compute_corrections(fasta_file):\n    reads = [str(record.seq) for record in SeqIO.parse(fasta_file, \"fasta\")]\n    counts = Counter(reads + [str(Seq(read).reverse_complement()) for read in reads])\n\n    correct_reads = {read for read in counts if counts[read] > 1}\n    incorrect_reads = [read for read in counts if counts[read] == 1]\n\n    def is_hamming_distance_one(r1, r2):\n        return sum(a != b for a, b in zip(r1, r2)) == 1\n\n    corrections = []\n    for incorrect_read in incorrect_reads:\n        for correct_read in correct_reads:\n            if is_hamming_distance_one(incorrect_read, correct_read):\n                corrections.append(f\"{incorrect_read}->{correct_read}\")\n                break\n            if is_hamming_distance_one(incorrect_read, str(Seq(correct_read).reverse_complement())):\n                corrections.append(f\"{incorrect_read}->{correct_read}\")\n                break\n\n    return corrections\n\nresult = compute_corrections(\"sample.fasta\")\nprint(result)",
    "from math import ceil\nn = 4\ninternal_nodes = n - 2\nresult = internal_nodes\nprint(result)",
    "from Bio import SeqIO\nfrom itertools import product\n\n# Read the DNA string from FASTA format\nwith open('sample.fasta', 'r') as file:\n    record = next(SeqIO.parse(file, 'fasta'))\n    s = str(record.seq)\n\nk = 4\nkmers = [''.join(p) for p in product('ACGT', repeat=k)]\nkmer_counts = {kmer: 0 for kmer in kmers}\n\nfor i in range(len(s) - k + 1):\n    kmer = s[i:i+k]\n    if kmer in kmer_counts:\n        kmer_counts[kmer] += 1\n\nresult = [kmer_counts[kmer] for kmer in sorted(kmer_counts)]\nprint(result)",
    "from Bio import SeqIO\n\ndef compute_failure_array(s):\n    n = len(s)\n    P = [0] * n\n    k = 0\n    for q in range(2, n + 1):\n        while k > 0 and s[k] != s[q - 1]:\n            k = P[k - 1]\n        if s[k] == s[q - 1]:\n            k += 1\n        P[q - 1] = k\n    return P\n\nrecord = next(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns = str(record.seq)\n\nresult = compute_failure_array(s)\nprint(result)",
    "from Bio import SeqIO\n\ndef longest_common_subsequence(s, t):\n    m, n = len(s), len(t)\n    dp = [[\"\"] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m):\n        for j in range(n):\n            if s[i] == t[j]:\n                dp[i + 1][j + 1] = dp[i][j] + s[i]\n            else:\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1], key=len)\n    \n    return dp[m][n]\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns = str(records[0].seq)\nt = str(records[1].seq)\n\nresult = longest_common_subsequence(s, t)\nprint(result)",
    "from itertools import product\n\ndef lexicographic_enum(alphabet, n):\n    results = []\n    for i in range(1, n + 1):\n        results.extend([''.join(p) for p in product(alphabet, repeat=i)])\n    return results\n\ndataset = \"\"\"\nD N A\n3\n\"\"\"\n\nlines = dataset.strip().split('\\n')\nalphabet = lines[0].split()\nn = int(lines[1])\n\nresult = lexicographic_enum(alphabet, n)\nresult.sort(key=lambda word: [alphabet.index(c) for c in word])\n\nprint(result)",
    "from Bio import SeqIO\n\ndef hamming_distance(s, t):\n    return sum(1 for a, b in zip(s, t) if a != b)\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns = str(records[0].seq)\nt = str(records[1].seq)\n\nresult = hamming_distance(s, t)\nprint(result)",
    "from itertools import combinations\nfrom math import comb, log10\n\ndef sibling_chromosome_log_probability(n):\n    total_chromosomes = 2 * n\n    result = []\n    for k in range(total_chromosomes - 1, -1, -1):\n        prob = sum(comb(total_chromosomes, i) * (0.5 ** total_chromosomes)\n                   for i in range(k, total_chromosomes + 1))\n        result.append(log10(prob))\n    return result\n\nn = 5\nresult = sibling_chromosome_log_probability(n)\nprint(result)",
    "from Bio import SeqIO\n\ndef p_distance(s1, s2):\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2)) / len(s1)\n\ndef compute_p_distance_matrix(sequences):\n    n = len(sequences)\n    matrix = []\n    \n    for i in range(n):\n        row = []\n        for j in range(n):\n            if i == j:\n                row.append(0.0)\n            else:\n                row.append(p_distance(sequences[i], sequences[j]))\n        matrix.append(row)\n    \n    return matrix\n\ndef read_fasta(file_path):\n    records = list(SeqIO.parse(file_path, \"fasta\"))\n    sequences = [str(record.seq) for record in records]\n    return sequences\n\nfasta_file = \"data.fasta\"\nsequences = read_fasta(fasta_file)\nresult = compute_p_distance_matrix(sequences)\nprint(result)",
    "from Bio import SeqIO\n\ndef transition_transversion_ratio(s1, s2):\n    transitions = 0\n    transversions = 0\n    \n    transition_pairs = [('A', 'G'), ('G', 'A'), ('C', 'T'), ('T', 'C')]\n    transversion_pairs = [('A', 'C'), ('C', 'A'), ('A', 'T'), ('T', 'A'), \n                          ('G', 'C'), ('C', 'G'), ('G', 'T'), ('T', 'G')]\n    \n    for base1, base2 in zip(s1, s2):\n        if base1 != base2:\n            if (base1, base2) in transition_pairs:\n                transitions += 1\n            elif (base1, base2) in transversion_pairs:\n                transversions += 1\n    if transversions == 0:\n        return float('inf')\n    return transitions / transversions\n\ndef read_fasta(file_path):\n    records = list(SeqIO.parse(file_path, \"fasta\"))\n    s1 = str(records[0].seq)\n    s2 = str(records[1].seq)\n    return s1, s2\n\nfasta_file = \"sample_dataset.fasta\"\ns1, s2 = read_fasta(fasta_file)\nresult = transition_transversion_ratio(s1, s2)\nprint(result)",
    "def total_number_of_subsets(n):\n    modulus = 1000000\n    # Total number of subsets of a set with n elements is 2^n\n    total_subsets = pow(2, n, modulus)\n    return total_subsets\n\nn = 3\nresult = total_number_of_subsets(n)\nprint(result)",
    "from Bio import SeqIO\nfrom Bio.Align import substitution_matrices\nimport numpy as np\n\ndef edit_distance_s_t(fasta_file):\n    records = list(SeqIO.parse(fasta_file, \"fasta\"))\n    seq1 = str(records[0].seq)\n    seq2 = str(records[1].seq)\n    \n    len_s = len(seq1)\n    len_t = len(seq2)\n    \n    dp = np.zeros((len_s + 1, len_t + 1), dtype=int)\n    \n    for i in range(len_s + 1):\n        dp[i][0] = i\n    for j in range(len_t + 1):\n        dp[0][j] = j\n    \n    for i in range(1, len_s + 1):\n        for j in range(1, len_t + 1):\n            if seq1[i - 1] == seq2[j - 1]:\n                cost = 0\n            else:\n                cost = 1\n            dp[i][j] = min(dp[i - 1][j] + 1,  # Deletion\n                           dp[i][j - 1] + 1,  # Insertion\n                           dp[i - 1][j - 1] + cost)  # Substitution\n\n    return dp[len_s][len_t]\n\nresult = edit_distance_s_t(\"path/to/your/fasta_file.fasta\")\nprint(result)",
    "from Bio import SeqIO\n\ndef compute_failure_array(s):\n    n = len(s)\n    P = [0] * n\n    k = 0\n    for i in range(2, n + 1):\n        while k > 0 and s[k] != s[i - 1]:\n            k = P[k - 1]\n        if s[k] == s[i - 1]:\n            k += 1\n        P[i - 1] = k\n    return P\n\nrecord = next(SeqIO.parse('input.fasta', 'fasta'))\nS = str(record.seq)\n\nresult = compute_failure_array(S)\nprint(result)",
    "from Bio import SeqIO\n\ndef motzkin_number(n):\n    if n == 0 or n == 1:\n        return 1\n    motzkin = [0] * (n + 1)\n    motzkin[0] = 1\n    motzkin[1] = 1\n    for i in range(2, n + 1):\n        motzkin[i] = motzkin[i - 1]\n        for k in range(2, i + 1):\n            motzkin[i] += motzkin[k - 2] * motzkin[i - k]\n    return motzkin[n]\n\ndef noncrossing_matchings(rna):\n    base_pairs = {'A': 'U', 'U': 'A', 'G': 'C', 'C': 'G'}\n    length = len(rna)\n    if length <= 1:\n        return 1\n\n    motzkin = [1] * (length + 1)\n    for n in range(2, length + 1):\n        motzkin[n] = motzkin[n - 1]\n        for k in range(2, n + 1):\n            if rna[0] == base_pairs.get(rna[k - 1], ''):\n                motzkin[n] += motzkin[k - 2] * motzkin[n - k]\n        motzkin[n] %= 1000000\n    return motzkin[length]\n\nrecord = next(SeqIO.parse(\"input.fasta\", \"fasta\"))\nS = str(record.seq)\n\nresult = noncrossing_matchings(S)\nprint(result)",
    "from Bio import Phylo\nfrom io import StringIO\n\ndef newick_node_distance(trees_with_nodes):\n    distances = []\n    for newick, nodes in trees_with_nodes:\n        tree = Phylo.read(StringIO(newick), \"newick\")\n        node1, node2 = nodes\n        tree.root_at_midpoint()\n        \n        # Find common ancestor and calculate distance\n        common_ancestor = tree.common_ancestor(node1, node2)\n        distance = tree.distance(common_ancestor, node1) + tree.distance(common_ancestor, node2)\n        distances.append(int(distance))\n    \n    return distances\n\ndataset = [\n    (\"(cat)dog;\", (\"dog\", \"cat\")),\n    (\"(dog,cat);\", (\"dog\", \"cat\"))\n]\n\nresult = newick_node_distance(dataset)\nprint(result)",
    "from Bio.Seq import Seq\n\ndef rna_to_protein(rna_sequence):\n    rna_seq = Seq(rna_sequence)\n    protein_seq = rna_seq.translate(to_stop=True)\n    return str(protein_seq)\n\nrna_string = \"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\"\nresult = rna_to_protein(rna_string)\nprint(result)",
    "from Bio import SeqIO\n\ndef calculate_transition_transversion_ratio(s1, s2):\n    transitions = 0\n    transversions = 0\n    transitions_set = {('A', 'G'), ('G', 'A'), ('C', 'T'), ('T', 'C')}\n    transversions_set = {('A', 'C'), ('C', 'A'), ('A', 'T'), ('T', 'A'),\n                         ('G', 'C'), ('C', 'G'), ('G', 'T'), ('T', 'G')}\n    \n    for b1, b2 in zip(s1, s2):\n        if b1 != b2:\n            if (b1, b2) in transitions_set:\n                transitions += 1\n            elif (b1, b2) in transversions_set:\n                transversions += 1\n    \n    return transitions / transversions if transversions != 0 else float('inf')\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns1 = str(records[0].seq)\ns2 = str(records[1].seq)\n\nresult = calculate_transition_transversion_ratio(s1, s2)\nprint(result)",
    "from Bio import Phylo\nfrom io import StringIO\n\ndef calculate_weighted_distances(trees, node_pairs):\n    distances = []\n\n    for (newick, (node1, node2)) in zip(trees, node_pairs):\n        tree = Phylo.read(StringIO(newick), \"newick\")\n        distance = tree.distance(node1, node2)\n        distances.append(distance)\n\n    return distances\n\ntrees = [\n    \"(dog:42,cat:33);\",\n    \"((dog:4,cat:3):74,robot:98,elephant:58);\"\n]\n\nnode_pairs = [\n    (\"cat\", \"dog\"),\n    (\"dog\", \"elephant\")\n]\n\nresult = calculate_weighted_distances(trees, node_pairs)\nprint(result)",
    "from itertools import product\n\ndef calculate_expected_values(n, P):\n    B = [n * p for p in P]\n    return B\n\nn = 17\nP = [0.1, 0.2, 0.3]\nresult = calculate_expected_values(n, P)\nprint(result)",
    "from collections import Counter\n\ndef minkowski_difference(S1, S2):\n    difference = Counter(s1 - s2 for s1 in S1 for s2 in S2)\n    max_multiplicity = max(difference.values())\n    max_diff = max(difference, key=difference.get)\n    return max_multiplicity, abs(max_diff)\n\nS1 = [\n    186.07931, 287.12699, 548.20532, 580.18077, 681.22845,\n    706.27446, 782.27613, 968.35544, 968.35544\n]\nS2 = [\n    101.04768, 158.06914, 202.09536, 318.09979, 419.14747,\n    463.17369\n]\n\nresult = minkowski_difference(S1, S2)\nprint(result)",
    "from itertools import product\n\ndef create_character_table(dna_strings):\n    n = len(dna_strings)\n    m = len(dna_strings[0])\n\n    char_table = []\n\n    for i in range(m):\n        col_symbols = set(string[i] for string in dna_strings)\n        if len(col_symbols) == 2:  # Characterizable: only two types of symbols in this position\n            reference_symbol = dna_strings[0][i]\n            char_table.append([1 if string[i] == reference_symbol else 0 for string in dna_strings])\n\n    return char_table\n\ndna_strings = [\n    \"ATGCTACC\",\n    \"CGTTTACC\",\n    \"ATTCGACC\",\n    \"AGTCTCCC\",\n    \"CGTCTATC\",\n]\n\nresult = create_character_table(dna_strings)\nfor row in result:\n    print(row)",
    "from Bio.Seq import Seq\nfrom collections import defaultdict\n\ndef reverse_complement(seq):\n    return str(Seq(seq).reverse_complement())\n\ndef de_bruijn_graph(kmers):\n    adj_list = defaultdict(set)\n    all_kmers = set(kmers)\n\n    for kmer in kmers:\n        all_kmers.add(reverse_complement(kmer))\n    \n    for kmer in all_kmers:\n        adj_list[kmer[:-1]].add(kmer[1:])\n\n    return adj_list\n\ndataset = [\n    \"TGAT\",\n    \"CATG\",\n    \"TCAT\",\n    \"ATGC\",\n    \"CATC\",\n    \"CATC\"\n]\n\ngraph = de_bruijn_graph(dataset)\nresult = sorted([(key, val) for key in graph for val in sorted(graph[key])])\nprint(result)",
    "from Bio import SeqIO\nfrom Bio import Align\naligner = Align.PairwiseAligner()\naligner.mode = 'global'\naligner.match = 1\naligner.mismatch = -1\naligner.open_gap_score = -1\naligner.extend_gap_score = -1\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\nseq1 = str(records[0].seq)\nseq2 = str(records[1].seq)\n\nalignments = aligner.align(seq1, seq2)\noptimal_alignment = alignments[0]\n\nd_e = optimal_alignment.score\ns_prime, t_prime = optimal_alignment.aligned[0], optimal_alignment.aligned[1]\n\ns_augmented = ''.join(seq1[i] if (i, i+1) in s_prime else '-' for i in range(len(optimal_alignment[0])))\nt_augmented = ''.join(seq2[i] if (i, i+1) in t_prime else '-' for i in range(len(optimal_alignment[1])))\n\nresult = (d_e, s_augmented, t_augmented)\nprint(result)",
    "from Bio import SeqIO\n\ndef hamming_distance(s, t):\n    return sum(el1 != el2 for el1, el2 in zip(s, t))\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns = str(records[0].seq)\nt = str(records[1].seq)\n\nresult = hamming_distance(s, t)\nprint(result)",
    "import math\n\ndef calculate_probabilities(n):\n    total_chromosomes = 2 * n\n    probabilities = []\n    \n    for k in range(total_chromosomes + 1):\n        prob = sum(math.comb(total_chromosomes, i) * (0.5 ** total_chromosomes) for i in range(k, total_chromosomes + 1))\n        probabilities.append(math.log10(prob))\n    \n    return probabilities\n\nn = 5\nresult = calculate_probabilities(n)\nprint(result)",
    "def can_interweave(S, t, u):\n    len_s, len_t, len_u = len(S), len(t), len(u)\n    dp = [[False] * (len_u + 1) for _ in range(len_t + 1)]\n    dp[0][0] = True\n    \n    for i in range(len_t + 1):\n        for j in range(len_u + 1):\n            if i > 0 and dp[i - 1][j] and S[i + j - 1] == t[i - 1]:\n                dp[i][j] = True\n            if j > 0 and dp[i][j - 1] and S[i + j - 1] == u[j - 1]:\n                dp[i][j] = True\n    \n    return dp[len_t][len_u]\n\ndef interweave_matrix(S, patterns):\n    n = len(patterns)\n    M = [[0] * n for _ in range(n)]\n    \n    for j in range(n):\n        for k in range(n):\n            if can_interweave(S, patterns[j], patterns[k]):\n                M[j][k] = 1\n                \n    return M\n\nS = \"GACCACGGTT\"\npatterns = [\"ACAG\", \"GT\", \"CCG\"]\n\nresult = interweave_matrix(S, patterns)\nprint(result)",
    "from Bio.Seq import Seq\n\ndef translate_rna_to_protein(rna_string):\n    rna_seq = Seq(rna_string)\n    protein_seq = rna_seq.translate(to_stop=True)\n    return str(protein_seq)\n\nrna_string = \"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\"\nresult = translate_rna_to_protein(rna_string)\nprint(result)",
    "from Bio import Align\nfrom Bio import SeqIO\nfrom Bio.Align.substitution_matrices import load\n\naligner = Align.PairwiseAligner()\nblosum62 = load(\"BLOSUM62\")\n\naligner.substitution_matrix = blosum62\naligner.open_gap_score = -11\naligner.extend_gap_score = -1\n\ndef align_sequences(file_name):\n    records = list(SeqIO.parse(file_name, \"fasta\"))\n    seq1 = str(records[0].seq)\n    seq2 = str(records[1].seq)\n\n    alignments = aligner.align(seq1, seq2)\n    best_alignment = alignments[0]\n\n    aligned_seq1 = best_alignment.seqA\n    aligned_seq2 = best_alignment.seqB\n    score = best_alignment.score\n\n    return score, aligned_seq1, aligned_seq2\n\nresult = align_sequences(\"sample.fasta\")\nprint(result)",
    "from Bio import Phylo\nfrom io import StringIO\nfrom itertools import combinations\n\ndef count_quartets(n, newick_tree):\n    tree = Phylo.read(StringIO(newick_tree), \"newick\")\n    nodes = list(tree.get_terminals())\n    node_names = [node.name for node in nodes]\n    \n    num_quartets = 0\n    for a, b, c, d in combinations(node_names, 4):\n        if tree.common_ancestor(a, b) != tree.common_ancestor(c, d):\n            num_quartets += 1\n\n    return num_quartets\n\nn = 6\nnewick_tree = \"(lobster,(cat,dog),(caterpillar,(elephant,mouse)));\"\nresult = count_quartets(n, newick_tree) % 1000000\nprint(result)",
    "def expected_binomial(n, probabilities):\n    return [n * p for p in probabilities]\n\nn = 17\nP = [0.1, 0.2, 0.3]\n\nresult = expected_binomial(n, P)\nprint(result)",
    "from math import sqrt\n\ndef hardy_weinberg_equilibrium_probabilities(homozygous_recessive):\n    return [1 - sqrt(h) for h in homozygous_recessive]\n\nA = [0.1, 0.25, 0.5]\nresult = hardy_weinberg_equilibrium_probabilities(A)\nprint(result)",
    "from Bio import SeqIO\nfrom Bio.Seq import Seq\ns, t = [str(record.seq) for record in SeqIO.parse('sequences.fasta', 'fasta')]\nm, n = len(s), len(t)\ndp = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(m + 1):\n    dp[i][0] = 1\nfor j in range(n + 1):\n    dp[0][j] = 1\nfor i in range(1, m + 1):\n    for j in range(1, n + 1):\n        if s[i - 1] == t[j - 1]:\n            dp[i][j] = dp[i - 1][j - 1]\n        else:\n            dp[i][j] = 0\n        dp[i][j] += dp[i - 1][j] + dp[i][j - 1]\n        dp[i][j] %= 134217727\nresult = dp[m][n]\nprint(result)",
    "from itertools import permutations\nfrom Bio.Seq import Seq\n\ndef construct_superstring(kmers):\n    def overlp(a, b):\n        max_ov = 0\n        for i in range(1, len(a)):\n            if b.startswith(a[i:]):\n                max_ov = len(a) - i\n        return max_ov\n\n    for perm in permutations(kmers):\n        superstring = perm[0]\n        for i in range(1, len(perm)):\n            overlap_len = overlp(superstring, perm[i])\n            superstring += perm[i][overlap_len:]\n        if all([superstring.count(kmer) > 0 for kmer in kmers]):\n            return superstring\n\nkmers = [\"ATTAC\", \"TACAG\", \"GATTA\", \"ACAGA\", \"CAGAT\", \"TTACA\", \"AGATT\"]\nresult = construct_superstring(kmers)\nprint(result)",
    "from Bio import SeqIO\n\ndef gc_content(seq):\n    return (seq.count('G') + seq.count('C')) / len(seq) * 100\n\ndef highest_gc_content(fasta_filename):\n    highest_gc = 0\n    highest_id = \"\"\n    for record in SeqIO.parse(fasta_filename, \"fasta\"):\n        gc = gc_content(str(record.seq))\n        if gc > highest_gc:\n            highest_gc = gc\n            highest_id = record.id\n    return highest_id, highest_gc\n\nfasta_filename = \"sample.fasta\"\nresult = highest_gc_content(fasta_filename)\nprint(result)",
    "# Sample Problem Code\n\ndef hamming_distance(s, t):\n    return sum(1 for x, y in zip(s, t) if x != y)\n\ns = \"GAGCCTACTAACGGGAT\"\nt = \"CATCGTAATGACGGCCT\"\n\nresult = hamming_distance(s, t)\nprint(result)",
    "import math\nfrom scipy.stats import binom\n\ndef log_probabilities(n):\n    A = []\n    for k in range(2*n + 1):\n        p = 1 - binom.cdf(k - 1, 2*n, 0.5)\n        log_p = math.log10(p)\n        A.append(log_p)\n    return A\n\nn = 5\nresult = log_probabilities(n)\nprint(result)",
    "from Bio.Seq import Seq\n\ndef translate_rna_to_protein(rna_string):\n    rna_seq = Seq(rna_string)\n    protein_seq = rna_seq.translate(to_stop=True)\n    return str(protein_seq)\n\nrna_string = \"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\"\nresult = translate_rna_to_protein(rna_string)\nprint(result)",
    "from Bio.Seq import Seq\nfrom Bio.SeqRecord import SeqRecord\nfrom Bio.SeqIO import parse\n\ndef calculate_transition_transversion_ratio(dna1, dna2):\n    transitions = 0\n    transversions = 0\n    purines = {'A', 'G'}\n    pyrimidines = {'C', 'T'}\n    \n    for nucleotide1, nucleotide2 in zip(dna1, dna2):\n        if nucleotide1 != nucleotide2:\n            if {nucleotide1, nucleotide2} <= purines or {nucleotide1, nucleotide2} <= pyrimidines:\n                transitions += 1\n            else:\n                transversions += 1\n                \n    return transitions / transversions if transversions != 0 else float('inf')\n\n# Example sequences from the problem\ndna1 = \"GCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGAAGTACGGGCATCAACCCAGTT\"\ndna2 = \"TTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGCAGGTACGAGTGTTCCTTTGGGT\"\n\nresult = calculate_transition_transversion_ratio(dna1, dna2)\nprint(result)",
    "from Bio import Align\nfrom Bio.Align.substitution_matrices import load\n\ndef affine_gap_alignment(seq1, seq2, open_gap_penalty, extend_gap_penalty):\n    blosum62 = load(\"BLOSUM62\")\n    aligner = Align.PairwiseAligner()\n    aligner.substitution_matrix = blosum62\n    aligner.open_gap_score = -open_gap_penalty\n    aligner.extend_gap_score = -extend_gap_penalty\n\n    alignments = list(aligner.align(seq1, seq2))\n    max_score = alignments[0].score\n    s_prime, t_prime = str(alignments[0][0].seq), str(alignments[0][1].seq)\n    \n    return max_score, s_prime, t_prime\n\n# Sample dataset sequences\nseq1 = \"PRTEINS\"\nseq2 = \"PRTWPSEIN\"\n\nresult = affine_gap_alignment(seq1, seq2, 11, 1)\nprint(result)",
    "import itertools\n\ndef generate_unrooted_trees(taxa):\n    def format_newick(tree, names):\n        if not isinstance(tree, tuple):\n            return names[tree]\n        return f\"({format_newick(tree[0], names)},{format_newick(tree[1], names)})\"\n\n    trees = []\n    indices = list(range(len(taxa) - 1))\n\n    for pairs in itertools.combinations(indices, len(taxa) - 3):\n        current_tree = 0\n        for i, (a, b) in enumerate(itertools.zip_longest(pairs, pairs[1:], fillvalue=len(taxa))):\n            current_tree = (a, current_tree) if a == i or b == i else (current_tree, a)\n        trees.append(format_newick(current_tree, taxa))\n\n    return trees\n\nspecies_list = [\"dog\", \"cat\", \"mouse\", \"elephant\"]\nresult = generate_unrooted_trees(species_list)\nprint(\"\\n\".join(result))",
    "from Bio.Seq import Seq\n\ndef cyclic_superstring(reads):\n    def reverse_complement(read):\n        return str(Seq(read).reverse_complement())\n\n    def overlap(a, b):\n        max_overlap = 0\n        min_len = min(len(a), len(b))\n        for i in range(1, min_len):\n            if a.endswith(b[:i]):\n                max_overlap = i\n        return max_overlap\n\n    used_reads = set()\n    cyclic_str = reads[0]  # Start with the first read\n    used_reads.add(cyclic_str)\n\n    while len(used_reads) < len(reads):\n        current_overlap = 0\n        next_read = \"\"\n\n        for read in reads:\n            if read in used_reads:\n                continue\n\n            # Check for overlap in both orientations\n            read_rc = reverse_complement(read)\n            for candidate_read in [read, read_rc]:\n                ol = overlap(cyclic_str, candidate_read)\n                if ol > current_overlap:\n                    current_overlap = ol\n                    next_read = candidate_read\n\n        cyclic_str += next_read[current_overlap:]\n        used_reads.add(next_read)\n\n    return cyclic_str\n\nreads = [\"AATCT\", \"TGTAA\", \"GATTA\", \"ACAGA\"]\nresult = cyclic_superstring(reads)\nprint(result)",
    "from Bio import Align\nfrom Bio.Align.substitution_matrices import load\nfrom Bio import SeqIO\n\nblosum62 = load('BLOSUM62')\naligner = Align.PairwiseAligner()\naligner.substitution_matrix = blosum62\naligner.open_gap_score = -5\naligner.extend_gap_score = -5\n\nrecords = list(SeqIO.parse('dataset.fasta', 'fasta'))\ns = str(records[0].seq)\nt = str(records[1].seq)\n\nalignment_score = aligner.score(s, t)\nresult = int(alignment_score)\nprint(result)",
    "from Bio.Seq import Seq\n\ns = \"AAAACCCGGT\"\ndna_seq = Seq(s)\n\nreverse_complement = dna_seq.reverse_complement()\n\nresult = str(reverse_complement)\nprint(result)",
    "from Bio import SeqIO\nfrom Bio.Align import substitution_matrices\nfrom Bio.Align import PairwiseAligner\n\ndef local_alignment(fasta_file):\n    # Load PAM250 scoring matrix\n    pam250 = substitution_matrices.load(\"PAM250\")\n    \n    # Set up aligner\n    aligner = PairwiseAligner()\n    aligner.substitution_matrix = pam250\n    aligner.open_gap_score = -5\n    aligner.extend_gap_score = -5\n    aligner.mode = 'local'\n    \n    # Read sequences from FASTA\n    records = list(SeqIO.parse(fasta_file, \"fasta\"))\n    seq1 = str(records[0].seq)\n    seq2 = str(records[1].seq)\n    \n    # Align sequences\n    alignments = aligner.align(seq1, seq2)\n    max_alignment = alignments[0]\n    \n    r_start, r_end = max_alignment.query_start, max_alignment.query_end\n    u_start, u_end = max_alignment.target_start, max_alignment.target_end\n    \n    r = seq1[r_start:r_end]\n    u = seq2[u_start:u_end]\n    \n    return int(max_alignment.score), r, u\n\nresult = local_alignment(\"sample.fasta\")\nprint(result)",
    "from itertools import product\n\nalphabet = \"DNA\"\nn = 3\n\ndef generate_strings(alphabet, n):\n    all_strings = []\n    for i in range(1, n + 1):\n        for p in product(alphabet, repeat=i):\n            all_strings.append(\"\".join(p))\n    return sorted(all_strings)\n\nresult = generate_strings(alphabet, n)\nprint(result)",
    "k, m, n = 2, 2, 2\n\ntotal = k + m + n\n\nprob_homozygous_dominant = (k / total) * ((k - 1) / (total - 1))\nprob_heterozygous = (m / total) * ((m - 1) / (total - 1))\nprob_homozygous_recessive = (n / total) * ((n - 1) / (total - 1))\n\nprob_km = (k / total) * (m / (total - 1)) + (m / total) * (k / (total - 1))\nprob_kn = (k / total) * (n / (total - 1)) + (n / total) * (k / (total - 1))\nprob_mn = (m / total) * (n / (total - 1)) + (n / total) * (m / (total - 1))\n\nprob_dom_phenotype = prob_homozygous_dominant + prob_heterozygous * 0.75 + prob_km + prob_kn + prob_mn * 0.5\n\nresult = prob_dom_phenotype\nprint(result)",
    "from Bio.Seq import Seq\n\ndef calculate_probability(N, X, S):\n    p_gc = X / 2\n    p_at = (1 - X) / 2\n    p_S = 1\n    \n    for nucleotide in S:\n        if nucleotide in \"GC\":\n            p_S *= p_gc\n        else:\n            p_S *= p_at\n    \n    p_complement = (1 - p_S) ** N\n    return 1 - p_complement\n\nN = 90000\nX = 0.6\nS = \"ATAGCCGA\"\n\nresult = calculate_probability(N, X, S)\nprint(result)",
    "from Bio.Align import substitution_matrices\nfrom Bio import pairwise2\nfrom Bio.Seq import Seq\nfrom Bio.SeqRecord import SeqRecord\nfrom Bio import SeqIO\n\ndef affine_gap_alignment(fasta_file):\n    blosum62 = substitution_matrices.load(\"BLOSUM62\")\n    \n    records = list(SeqIO.parse(fasta_file, \"fasta\"))\n    s1 = str(records[0].seq)\n    s2 = str(records[1].seq)\n    \n    alignments = pairwise2.align.globalds(s1, s2, blosum62, -11, -1)\n    best_alignment = alignments[0]\n    \n    alignment_score = best_alignment.score\n    alignment_s1 = best_alignment.seqA\n    alignment_s2 = best_alignment.seqB\n    \n    return int(alignment_score), alignment_s1, alignment_s2\n\nresult = affine_gap_alignment(\"sample.fasta\")\nprint(result)",
    "from math import log10\nimport numpy as np\n\nN = 4\nm = 3\nA = [0, 1, 2]\n\ndef wright_fisher_log_prob(N, m, A):\n    prob_matrix = np.zeros((m, len(A)))\n    for i in range(len(A)):\n        num_recessive = A[i]\n        p = num_recessive / (2 * N)\n        for gen in range(m):\n            q = (1 - p) ** (2 * N)\n            prob_matrix[gen][i] = log10(q)\n    return prob_matrix\n\nresult = wright_fisher_log_prob(N, m, A)\nprint(result)",
    "from Bio import Align\nfrom Bio.Align import substitution_matrices\nfrom Bio import SeqIO\n\n# Load BLOSUM62 matrix\nblosum62 = substitution_matrices.load(\"BLOSUM62\")\n\n# Initialize aligner\naligner = Align.PairwiseAligner()\naligner.substitution_matrix = blosum62\naligner.open_gap_score = -11\naligner.extend_gap_score = -1\n\n# Read sequences from FASTA file\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\nS = str(records[0].seq)\nt = str(records[1].seq)\n\n# Perform alignment\nalignment = aligner.align(S, t)\n\n# Get scores and aligned sequences\nmax_score = alignment[0].score\nalign_s = alignment[0].aligned[0]\nalign_t = alignment[0].aligned[1]\n\n# Compute the sum of alignment scores\nscore_matrix_sum = sum(a.score for a in alignment)\n\nresult = (max_score, score_matrix_sum, align_s, align_t)\nprint(result)",
    "from Bio import SeqIO\nfrom Bio import Align\nfrom Bio.Align import substitution_matrices\n\n# Load BLOSUM62 matrix\nblosum62 = substitution_matrices.load(\"BLOSUM62\")\n\n# Initialize aligner with specified gap penalties\naligner = Align.PairwiseAligner()\naligner.substitution_matrix = blosum62\naligner.open_gap_score = -11\naligner.extend_gap_score = -1\naligner.mode = 'local'  # Local alignment\n\n# Read sequences from FASTA file\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns = str(records[0].seq)\nt = str(records[1].seq)\n\n# Perform local alignment\nalignment = aligner.align(s, t)[0]\n\n# Extract the score and aligned sequences\nmax_score = alignment.score\nr = alignment.query\nu = alignment.target\n\nresult = (max_score, r, u)\nprint(result)",
    "from Bio import pairwise2\nfrom Bio.pairwise2 import format_alignment\n\ndef edit_distance(S, T):\n    return pairwise2.align.globalms(S, T, 1, -1, -1, -1, score_only=True)\n\ndef find_substrings(k, S, t):\n    valid_substrings = []\n    for i in range(len(t) - len(S) + 1):\n        t_prime = t[i:i+len(S)]\n        if edit_distance(S, t_prime) <= k:\n            valid_substrings.append((i+1, len(S)))\n    return valid_substrings\n\nk = 2\nS = \"ACGTAG\"\nt = \"ACGGATCGGCACTCGT\"\nresult = find_substrings(k, S, t)\nprint(result)",
    "from Bio import pairwise2\nfrom Bio import SeqIO\n\ndef semiglobal_alignment(s, t):\n    alignments = pairwise2.align.globalms(s, t, 1, -1, -1, -1, penalize_end_gaps=(False, False))\n    max_score = alignments[0].score\n    best_alignment = alignments[0]\n    return max_score, best_alignment\n\nrecords = list(SeqIO.parse(\"sequences.fasta\", \"fasta\"))\ns = str(records[0].seq)\nt = str(records[1].seq)\n\nmax_score, best_alignment = semiglobal_alignment(s, t)\nalignment_info = (max_score, best_alignment[0], best_alignment[1])\n\nresult = alignment_info\nprint(result)",
    "from Bio import SeqIO\nfrom Bio.pairwise2 import format_alignment\nfrom Bio import pairwise2\n\ndef longest_common_subsequence(s, t):\n    m, n = len(s), len(t)\n    dp = [[\"\"] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + s[i - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)\n    \n    return dp[m][n]\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns = str(records[0].seq)\nt = str(records[1].seq)\n\nlongest_subsequence = longest_common_subsequence(s, t)\nresult = longest_subsequence\nprint(result)",
    "def hamming_distance(s, t):\n    return sum(el1 != el2 for el1, el2 in zip(s, t))\n\ns = \"GAGCCTACTAACGGGAT\"\nt = \"CATCGTAATGACGGCCT\"\nresult = hamming_distance(s, t)\nprint(result)",
    "from Bio import SeqIO\nfrom Bio.Align import PairwiseAligner\n\ndef overlap_alignment(fasta_file):\n    aligner = PairwiseAligner()\n    aligner.match_score = 1\n    aligner.mismatch_score = -2\n    aligner.open_gap_score = -2\n    aligner.extend_gap_score = -2\n    aligner.mode = 'local'\n    \n    records = list(SeqIO.parse(fasta_file, \"fasta\"))\n    S = str(records[0].seq)\n    t = str(records[1].seq)\n    \n    alignments = aligner.align(S, t)\n    # Extract optimal alignment\n    max_score = alignments[0].score\n    s_prime_aligned, t_prime_aligned = alignments[0].aligned\n    \n    # Determine the suffix of S and prefix of t that give the optimal alignment\n    s_start, t_start = s_prime_aligned[0][0], t_prime_aligned[0][0]\n    \n    # Create augmented strings\n    s_prime = \"\".join(S[i] if i >= s_start else \"-\" for i in range(len(alignments[0][0])))\n    t_prime = \"\".join(t[i] if i >= t_start else \"-\" for i in range(len(alignments[0][1])))\n    \n    return max_score, s_prime, t_prime\n\nresult = overlap_alignment(\"sample.fasta\")\nprint(result)",
    "from Bio import SeqIO\n\ndef compute_p_distance_matrix(sequences):\n    n = len(sequences)\n    D = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i][j] = sum(seq1 != seq2 for seq1, seq2 in zip(sequences[i], sequences[j])) / len(sequences[i])\n    return D\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\nsequences = [str(record.seq) for record in records]\n\nresult = compute_p_distance_matrix(sequences)\nfor row in result:\n    print(\" \".join(f\"{d:.5f}\" for d in row))",
    "from Bio import SeqIO\nfrom Bio.Seq import Seq\nfrom collections import Counter\n\ndef reverse_complement(seq):\n    return str(Seq(seq).reverse_complement())\n\ndef find_hamming_distance(s1, s2):\n    return sum(el1 != el2 for el1, el2 in zip(s1, s2))\n\ndef find_corrections(reads):\n    correct_reads = set()\n    read_counts = Counter(reads)\n\n    for read, count in read_counts.items():\n        if count > 1 or read_counts[reverse_complement(read)] > 1:\n            correct_reads.add(read)\n            correct_reads.add(reverse_complement(read))\n    \n    corrections = []\n    for read in reads:\n        if read not in correct_reads:\n            for correct_read in correct_reads:\n                if find_hamming_distance(read, correct_read) == 1:\n                    corrections.append(f\"{read}->{correct_read}\")\n                    break\n    \n    return corrections\n\nsequences = [str(record.seq) for record in SeqIO.parse(\"sample.fasta\", \"fasta\")]\n\nresult = find_corrections(sequences)\nfor correction in result:\n    print(correction)",
    "from Bio import Align\nfrom Bio import SeqIO\nfrom Bio import AlignIO\nfrom Bio.Align import substitution_matrices\n\n# Load BLOSUM62 matrix\nblosum62 = substitution_matrices.load(\"BLOSUM62\")\n\n# Set gap opening and extension penalties\ngap_opening_penalty = 11\ngap_extension_penalty = 1\n\n# Read sequences from FASTA\nsequences = []\nwith open(\"sample.fasta\", \"r\") as fasta_file:\n    for record in SeqIO.parse(fasta_file, \"fasta\"):\n        sequences.append(str(record.seq))\n\n# Create aligner object\naligner = Align.PairwiseAligner()\naligner.substitution_matrix = blosum62\naligner.open_gap_score = -gap_opening_penalty\naligner.extend_gap_score = -gap_extension_penalty\naligner.mode = 'global'\n\n# Perform alignment\nalignment = aligner.align(sequences[0], sequences[1])[0]\n\n# Retrieve results\nscore = alignment.score\naligned_seq1, aligned_seq2 = alignment.aligned\n\nresult = (score, aligned_seq1, aligned_seq2)\nprint(result)",
    "from itertools import combinations\nfrom math import comb\n\ndef count_valid_matchings(s):\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(i - 4, -1, -1):\n            if (s[j] == 'A' and s[i - 1] in 'U') or (s[j] == 'U' and s[i - 1] in 'AG') or \\\n               (s[j] == 'C' and s[i - 1] in 'G') or (s[j] == 'G' and s[i - 1] in 'CU'):\n                dp[i] += dp[j] * dp[i - j - 2]\n                dp[i] %= 1000000\n\n    return dp[n]\n\ns = \"AUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU\"\nresult = count_valid_matchings(s)\nprint(result)",
    "from Bio import SeqIO\nfrom Bio.Align import substitution_matrices\nfrom Bio.Seq import Seq\nfrom Bio.SeqRecord import SeqRecord\n\ndef expected_binomial(n, P):\n    return [n * p for p in P]\n\nP = [0.1, 0.2, 0.3]\nn = 17\n\nresult = expected_binomial(n, P)\nprint(result)",
    "from Bio import SeqIO\n\ndef calculate_NXX_statistics(contigs, percentage):\n    total_length = sum(len(contig) for contig in contigs)\n    threshold = (percentage * total_length) / 100\n    contigs_sorted = sorted(contigs, key=len, reverse=True)\n    cumulative_length = 0\n    for contig in contigs_sorted:\n        cumulative_length += len(contig)\n        if cumulative_length >= threshold:\n            return len(contig)\n\ncontigs = [\"GATTACA\", \"TACTACTAC\", \"ATTGAT\", \"GAAGA\"]\n\nN50 = calculate_NXX_statistics(contigs, 50)\nN75 = calculate_NXX_statistics(contigs, 75)\n\nresult = (N50, N75)\nprint(result)",
    "from Bio.Seq import Seq\n\ns = \"AAAACCCGGT\"\ndna_seq = Seq(s)\nreverse_complement = dna_seq.reverse_complement()\n\nresult = str(reverse_complement)\nprint(result)",
    "import scipy.stats\n\ndef probability_recessive(N, m, g, k):\n    p = m / (2 * N)\n\n    current_generation = [scipy.stats.binom(2 * N, p)]\n    for _ in range(g):\n        next_generation = []\n        for dist in current_generation:\n            for h in range(2 * N + 1):\n                prob = dist.pmf(h)\n                if prob > 0:\n                    next_gen_dist = scipy.stats.binom(2 * N, h / (2 * N))\n                    next_generation.append(next_gen_dist)\n        current_generation = next_generation\n\n    prob_at_least_k = sum((dist.sf(k-1)) for dist in current_generation) / len(current_generation)\n    return prob_at_least_k\n\nN, m, g, k = 4, 6, 2, 1\nresult = probability_recessive(N, m, g, k)\nprint(result)",
    "from Bio import SeqIO\n\ndef hamming_distance(s, t):\n    assert len(s) == len(t), \"Strings must be of the same length\"\n    distance = sum(1 for sc, tc in zip(s, t) if sc != tc)\n    return distance\n\nrecords = list(SeqIO.parse(\"sample.fasta\", \"fasta\"))\ns = str(records[0].seq)\nt = str(records[1].seq)\n\nresult = hamming_distance(s, t)\nprint(result)",
    "def count_rooted_binary_trees(n):\n    B = [1] * (n + 1)  # Initialize list for storing B(i)\n    for i in range(2, n + 1):\n        B[i] = (B[i - 1] * (2 * i - 3)) % 1000000\n    return B[n]\n\nn = 4\nresult = count_rooted_binary_trees(n)\nprint(result)"
  ]
}